/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@ledgerhq/devices/lib-es/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/lib-es/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IIGenericHID\": () => (/* binding */ IIGenericHID),\n/* harmony export */   \"IIKeyboardHID\": () => (/* binding */ IIKeyboardHID),\n/* harmony export */   \"IIU2F\": () => (/* binding */ IIU2F),\n/* harmony export */   \"IICCID\": () => (/* binding */ IICCID),\n/* harmony export */   \"IIWebUSB\": () => (/* binding */ IIWebUSB),\n/* harmony export */   \"DeviceModelId\": () => (/* binding */ DeviceModelId),\n/* harmony export */   \"ledgerUSBVendorId\": () => (/* binding */ ledgerUSBVendorId),\n/* harmony export */   \"getDeviceModel\": () => (/* binding */ getDeviceModel),\n/* harmony export */   \"identifyTargetId\": () => (/* binding */ identifyTargetId),\n/* harmony export */   \"identifyUSBProductId\": () => (/* binding */ identifyUSBProductId),\n/* harmony export */   \"identifyProductName\": () => (/* binding */ identifyProductName),\n/* harmony export */   \"getBluetoothServiceUuids\": () => (/* binding */ getBluetoothServiceUuids),\n/* harmony export */   \"getInfosForServiceUuid\": () => (/* binding */ getInfosForServiceUuid)\n/* harmony export */ });\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ \"./node_modules/semver/index.js\");\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(semver__WEBPACK_IMPORTED_MODULE_0__);\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar _a;\n\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\nvar IIGenericHID = 0x01;\nvar IIKeyboardHID = 0x02;\nvar IIU2F = 0x04;\nvar IICCID = 0x08;\nvar IIWebUSB = 0x10;\nvar DeviceModelId;\n(function (DeviceModelId) {\n    DeviceModelId[\"blue\"] = \"blue\";\n    DeviceModelId[\"nanoS\"] = \"nanoS\";\n    DeviceModelId[\"nanoSP\"] = \"nanoSP\";\n    DeviceModelId[\"nanoX\"] = \"nanoX\";\n})(DeviceModelId || (DeviceModelId = {}));\nvar devices = (_a = {},\n    _a[DeviceModelId.blue] = {\n        id: DeviceModelId.blue,\n        productName: \"Ledger Blue\",\n        productIdMM: 0x00,\n        legacyUsbProductId: 0x0000,\n        usbOnly: true,\n        memorySize: 480 * 1024,\n        masks: [0x31000000, 0x31010000],\n        getBlockSize: function (_firwareVersion) { return 4 * 1024; }\n    },\n    _a[DeviceModelId.nanoS] = {\n        id: DeviceModelId.nanoS,\n        productName: \"Ledger Nano S\",\n        productIdMM: 0x10,\n        legacyUsbProductId: 0x0001,\n        usbOnly: true,\n        memorySize: 320 * 1024,\n        masks: [0x31100000],\n        getBlockSize: function (firmwareVersion) {\n            var _a;\n            return semver__WEBPACK_IMPORTED_MODULE_0___default().lt((_a = semver__WEBPACK_IMPORTED_MODULE_0___default().coerce(firmwareVersion)) !== null && _a !== void 0 ? _a : \"\", \"2.0.0\")\n                ? 4 * 1024\n                : 2 * 1024;\n        }\n    },\n    _a[DeviceModelId.nanoSP] = {\n        id: DeviceModelId.nanoSP,\n        productName: \"Ledger Nano SP\",\n        productIdMM: 0x50,\n        legacyUsbProductId: 0x0005,\n        usbOnly: true,\n        memorySize: 1533 * 1024,\n        masks: [0x33100000],\n        getBlockSize: function (_firmwareVersion) { return 32; }\n    },\n    _a[DeviceModelId.nanoX] = {\n        id: DeviceModelId.nanoX,\n        productName: \"Ledger Nano X\",\n        productIdMM: 0x40,\n        legacyUsbProductId: 0x0004,\n        usbOnly: false,\n        memorySize: 2 * 1024 * 1024,\n        masks: [0x33000000],\n        getBlockSize: function (_firwareVersion) { return 4 * 1024; },\n        bluetoothSpec: [\n            {\n                // this is the legacy one (prototype version). we will eventually drop it.\n                serviceUuid: \"d973f2e0-b19e-11e2-9e96-0800200c9a66\",\n                notifyUuid: \"d973f2e1-b19e-11e2-9e96-0800200c9a66\",\n                writeUuid: \"d973f2e2-b19e-11e2-9e96-0800200c9a66\"\n            },\n            {\n                serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n                notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n                writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\"\n            },\n        ]\n    },\n    _a);\nvar productMap = {\n    Blue: DeviceModelId.blue,\n    \"Nano S\": DeviceModelId.nanoS,\n    \"Nano X\": DeviceModelId.nanoX\n};\nvar devicesList = Object.values(devices);\n/**\n *\n */\nvar ledgerUSBVendorId = 0x2c97;\n/**\n *\n */\nvar getDeviceModel = function (id) {\n    var info = devices[id];\n    if (!info)\n        throw new Error(\"device '\" + id + \"' does not exist\");\n    return info;\n};\n/**\n * Given a `targetId`, return the deviceModel associated to it,\n * based on the first two bytes.\n */\nvar identifyTargetId = function (targetId) {\n    var deviceModel = devicesList.find(function (_a) {\n        var masks = _a.masks;\n        return masks.find(function (mask) { return (targetId & 0xffff0000) === mask; });\n    });\n    return deviceModel;\n};\n/**\n *\n */\nvar identifyUSBProductId = function (usbProductId) {\n    var legacy = devicesList.find(function (d) { return d.legacyUsbProductId === usbProductId; });\n    if (legacy)\n        return legacy;\n    var mm = usbProductId >> 8;\n    var deviceModel = devicesList.find(function (d) { return d.productIdMM === mm; });\n    return deviceModel;\n};\nvar identifyProductName = function (productName) {\n    var productId = productMap[productName];\n    if (!productId && productName.startsWith(\"Nano S\")) {\n        productId = DeviceModelId.nanoSP;\n    }\n    var deviceModel = devicesList.find(function (d) { return d.id === productId; });\n    return deviceModel;\n};\nvar bluetoothServices = [];\nvar serviceUuidToInfos = {};\nfor (var id in devices) {\n    var deviceModel = devices[id];\n    var bluetoothSpec = deviceModel.bluetoothSpec;\n    if (bluetoothSpec) {\n        for (var i = 0; i < bluetoothSpec.length; i++) {\n            var spec = bluetoothSpec[i];\n            bluetoothServices.push(spec.serviceUuid);\n            serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, \"\")] = __assign({ deviceModel: deviceModel }, spec);\n        }\n    }\n}\n/**\n *\n */\nvar getBluetoothServiceUuids = function () { return bluetoothServices; };\n/**\n *\n */\nvar getInfosForServiceUuid = function (uuid) { return serviceUuidToInfos[uuid.toLowerCase()]; };\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/@ledgerhq/devices/lib-es/index.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/devices/lib/hid-framing.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ledgerhq/devices/lib/hid-framing.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\nexports.__esModule = true;\nvar errors_1 = __webpack_require__(/*! @ledgerhq/errors */ \"./node_modules/@ledgerhq/errors/lib-es/index.js\");\nvar Tag = 0x05;\nfunction asUInt16BE(value) {\n    var b = Buffer.alloc(2);\n    b.writeUInt16BE(value, 0);\n    return b;\n}\nvar initialAcc = {\n    data: Buffer.alloc(0),\n    dataLength: 0,\n    sequence: 0\n};\n/**\n *\n */\nvar createHIDframing = function (channel, packetSize) {\n    return {\n        makeBlocks: function (apdu) {\n            var data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n            var blockSize = packetSize - 5;\n            var nbBlocks = Math.ceil(data.length / blockSize);\n            data = Buffer.concat([\n                data,\n                Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0),\n            ]);\n            var blocks = [];\n            for (var i = 0; i < nbBlocks; i++) {\n                var head = Buffer.alloc(5);\n                head.writeUInt16BE(channel, 0);\n                head.writeUInt8(Tag, 2);\n                head.writeUInt16BE(i, 3);\n                var chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n                blocks.push(Buffer.concat([head, chunk]));\n            }\n            return blocks;\n        },\n        reduceResponse: function (acc, chunk) {\n            var _a = acc || initialAcc, data = _a.data, dataLength = _a.dataLength, sequence = _a.sequence;\n            if (chunk.readUInt16BE(0) !== channel) {\n                throw new errors_1.TransportError(\"Invalid channel\", \"InvalidChannel\");\n            }\n            if (chunk.readUInt8(2) !== Tag) {\n                throw new errors_1.TransportError(\"Invalid tag\", \"InvalidTag\");\n            }\n            if (chunk.readUInt16BE(3) !== sequence) {\n                throw new errors_1.TransportError(\"Invalid sequence\", \"InvalidSequence\");\n            }\n            if (!acc) {\n                dataLength = chunk.readUInt16BE(5);\n            }\n            sequence++;\n            var chunkData = chunk.slice(acc ? 5 : 7);\n            data = Buffer.concat([data, chunkData]);\n            if (data.length > dataLength) {\n                data = data.slice(0, dataLength);\n            }\n            return {\n                data: data,\n                dataLength: dataLength,\n                sequence: sequence\n            };\n        },\n        getReducedResult: function (acc) {\n            if (acc && acc.dataLength === acc.data.length) {\n                return acc.data;\n            }\n        }\n    };\n};\nexports[\"default\"] = createHIDframing;\n//# sourceMappingURL=hid-framing.js.map\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/@ledgerhq/devices/lib/hid-framing.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/errors/lib-es/helpers.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ledgerhq/errors/lib-es/helpers.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addCustomErrorDeserializer\": () => (/* binding */ addCustomErrorDeserializer),\n/* harmony export */   \"createCustomErrorClass\": () => (/* binding */ createCustomErrorClass),\n/* harmony export */   \"deserializeError\": () => (/* binding */ deserializeError),\n/* harmony export */   \"serializeError\": () => (/* binding */ serializeError)\n/* harmony export */ });\n/* eslint-disable no-continue */\n/* eslint-disable no-unused-vars */\n/* eslint-disable no-param-reassign */\n/* eslint-disable no-prototype-builtins */\nvar __values = (undefined && undefined.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar errorClasses = {};\nvar deserializers = {};\nvar addCustomErrorDeserializer = function (name, deserializer) {\n    deserializers[name] = deserializer;\n};\nvar createCustomErrorClass = function (name) {\n    var C = function CustomError(message, fields) {\n        Object.assign(this, fields);\n        this.name = name;\n        this.message = message || name;\n        this.stack = new Error().stack;\n    };\n    C.prototype = new Error();\n    errorClasses[name] = C;\n    return C;\n};\n// inspired from https://github.com/programble/errio/blob/master/index.js\nvar deserializeError = function (object) {\n    if (typeof object === \"object\" && object) {\n        try {\n            // $FlowFixMe FIXME HACK\n            var msg = JSON.parse(object.message);\n            if (msg.message && msg.name) {\n                object = msg;\n            }\n        }\n        catch (e) {\n            // nothing\n        }\n        var error = void 0;\n        if (typeof object.name === \"string\") {\n            var name_1 = object.name;\n            var des = deserializers[name_1];\n            if (des) {\n                error = des(object);\n            }\n            else {\n                var constructor = name_1 === \"Error\" ? Error : errorClasses[name_1];\n                if (!constructor) {\n                    console.warn(\"deserializing an unknown class '\" + name_1 + \"'\");\n                    constructor = createCustomErrorClass(name_1);\n                }\n                error = Object.create(constructor.prototype);\n                try {\n                    for (var prop in object) {\n                        if (object.hasOwnProperty(prop)) {\n                            error[prop] = object[prop];\n                        }\n                    }\n                }\n                catch (e) {\n                    // sometimes setting a property can fail (e.g. .name)\n                }\n            }\n        }\n        else {\n            error = new Error(object.message);\n        }\n        if (!error.stack && Error.captureStackTrace) {\n            Error.captureStackTrace(error, deserializeError);\n        }\n        return error;\n    }\n    return new Error(String(object));\n};\n// inspired from https://github.com/sindresorhus/serialize-error/blob/master/index.js\nvar serializeError = function (value) {\n    if (!value)\n        return value;\n    if (typeof value === \"object\") {\n        return destroyCircular(value, []);\n    }\n    if (typeof value === \"function\") {\n        return \"[Function: \" + (value.name || \"anonymous\") + \"]\";\n    }\n    return value;\n};\n// https://www.npmjs.com/package/destroy-circular\nfunction destroyCircular(from, seen) {\n    var e_1, _a;\n    var to = {};\n    seen.push(from);\n    try {\n        for (var _b = __values(Object.keys(from)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            var value = from[key];\n            if (typeof value === \"function\") {\n                continue;\n            }\n            if (!value || typeof value !== \"object\") {\n                to[key] = value;\n                continue;\n            }\n            if (seen.indexOf(from[key]) === -1) {\n                to[key] = destroyCircular(from[key], seen.slice(0));\n                continue;\n            }\n            to[key] = \"[Circular]\";\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_c && !_c.done && (_a = _b[\"return\"])) _a.call(_b);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    if (typeof from.name === \"string\") {\n        to.name = from.name;\n    }\n    if (typeof from.message === \"string\") {\n        to.message = from.message;\n    }\n    if (typeof from.stack === \"string\") {\n        to.stack = from.stack;\n    }\n    return to;\n}\n//# sourceMappingURL=helpers.js.map\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/@ledgerhq/errors/lib-es/helpers.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/errors/lib-es/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@ledgerhq/errors/lib-es/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"serializeError\": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.serializeError),\n/* harmony export */   \"deserializeError\": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.deserializeError),\n/* harmony export */   \"createCustomErrorClass\": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass),\n/* harmony export */   \"addCustomErrorDeserializer\": () => (/* reexport safe */ _helpers__WEBPACK_IMPORTED_MODULE_0__.addCustomErrorDeserializer),\n/* harmony export */   \"AccountNameRequiredError\": () => (/* binding */ AccountNameRequiredError),\n/* harmony export */   \"AccountNotSupported\": () => (/* binding */ AccountNotSupported),\n/* harmony export */   \"AmountRequired\": () => (/* binding */ AmountRequired),\n/* harmony export */   \"BluetoothRequired\": () => (/* binding */ BluetoothRequired),\n/* harmony export */   \"BtcUnmatchedApp\": () => (/* binding */ BtcUnmatchedApp),\n/* harmony export */   \"CantOpenDevice\": () => (/* binding */ CantOpenDevice),\n/* harmony export */   \"CashAddrNotSupported\": () => (/* binding */ CashAddrNotSupported),\n/* harmony export */   \"CurrencyNotSupported\": () => (/* binding */ CurrencyNotSupported),\n/* harmony export */   \"DeviceAppVerifyNotSupported\": () => (/* binding */ DeviceAppVerifyNotSupported),\n/* harmony export */   \"DeviceGenuineSocketEarlyClose\": () => (/* binding */ DeviceGenuineSocketEarlyClose),\n/* harmony export */   \"DeviceNotGenuineError\": () => (/* binding */ DeviceNotGenuineError),\n/* harmony export */   \"DeviceOnDashboardExpected\": () => (/* binding */ DeviceOnDashboardExpected),\n/* harmony export */   \"DeviceOnDashboardUnexpected\": () => (/* binding */ DeviceOnDashboardUnexpected),\n/* harmony export */   \"DeviceInOSUExpected\": () => (/* binding */ DeviceInOSUExpected),\n/* harmony export */   \"DeviceHalted\": () => (/* binding */ DeviceHalted),\n/* harmony export */   \"DeviceNameInvalid\": () => (/* binding */ DeviceNameInvalid),\n/* harmony export */   \"DeviceSocketFail\": () => (/* binding */ DeviceSocketFail),\n/* harmony export */   \"DeviceSocketNoBulkStatus\": () => (/* binding */ DeviceSocketNoBulkStatus),\n/* harmony export */   \"DisconnectedDevice\": () => (/* binding */ DisconnectedDevice),\n/* harmony export */   \"DisconnectedDeviceDuringOperation\": () => (/* binding */ DisconnectedDeviceDuringOperation),\n/* harmony export */   \"EnpointConfigError\": () => (/* binding */ EnpointConfigError),\n/* harmony export */   \"EthAppPleaseEnableContractData\": () => (/* binding */ EthAppPleaseEnableContractData),\n/* harmony export */   \"FeeEstimationFailed\": () => (/* binding */ FeeEstimationFailed),\n/* harmony export */   \"FirmwareNotRecognized\": () => (/* binding */ FirmwareNotRecognized),\n/* harmony export */   \"HardResetFail\": () => (/* binding */ HardResetFail),\n/* harmony export */   \"InvalidXRPTag\": () => (/* binding */ InvalidXRPTag),\n/* harmony export */   \"InvalidAddress\": () => (/* binding */ InvalidAddress),\n/* harmony export */   \"InvalidAddressBecauseDestinationIsAlsoSource\": () => (/* binding */ InvalidAddressBecauseDestinationIsAlsoSource),\n/* harmony export */   \"LatestMCUInstalledError\": () => (/* binding */ LatestMCUInstalledError),\n/* harmony export */   \"UnknownMCU\": () => (/* binding */ UnknownMCU),\n/* harmony export */   \"LedgerAPIError\": () => (/* binding */ LedgerAPIError),\n/* harmony export */   \"LedgerAPIErrorWithMessage\": () => (/* binding */ LedgerAPIErrorWithMessage),\n/* harmony export */   \"LedgerAPINotAvailable\": () => (/* binding */ LedgerAPINotAvailable),\n/* harmony export */   \"ManagerAppAlreadyInstalledError\": () => (/* binding */ ManagerAppAlreadyInstalledError),\n/* harmony export */   \"ManagerAppRelyOnBTCError\": () => (/* binding */ ManagerAppRelyOnBTCError),\n/* harmony export */   \"ManagerAppDepInstallRequired\": () => (/* binding */ ManagerAppDepInstallRequired),\n/* harmony export */   \"ManagerAppDepUninstallRequired\": () => (/* binding */ ManagerAppDepUninstallRequired),\n/* harmony export */   \"ManagerDeviceLockedError\": () => (/* binding */ ManagerDeviceLockedError),\n/* harmony export */   \"ManagerFirmwareNotEnoughSpaceError\": () => (/* binding */ ManagerFirmwareNotEnoughSpaceError),\n/* harmony export */   \"ManagerNotEnoughSpaceError\": () => (/* binding */ ManagerNotEnoughSpaceError),\n/* harmony export */   \"ManagerUninstallBTCDep\": () => (/* binding */ ManagerUninstallBTCDep),\n/* harmony export */   \"NetworkDown\": () => (/* binding */ NetworkDown),\n/* harmony export */   \"NoAddressesFound\": () => (/* binding */ NoAddressesFound),\n/* harmony export */   \"NotEnoughBalance\": () => (/* binding */ NotEnoughBalance),\n/* harmony export */   \"NotEnoughBalanceToDelegate\": () => (/* binding */ NotEnoughBalanceToDelegate),\n/* harmony export */   \"NotEnoughBalanceInParentAccount\": () => (/* binding */ NotEnoughBalanceInParentAccount),\n/* harmony export */   \"NotEnoughSpendableBalance\": () => (/* binding */ NotEnoughSpendableBalance),\n/* harmony export */   \"NotEnoughBalanceBecauseDestinationNotCreated\": () => (/* binding */ NotEnoughBalanceBecauseDestinationNotCreated),\n/* harmony export */   \"NoAccessToCamera\": () => (/* binding */ NoAccessToCamera),\n/* harmony export */   \"NotEnoughGas\": () => (/* binding */ NotEnoughGas),\n/* harmony export */   \"NotSupportedLegacyAddress\": () => (/* binding */ NotSupportedLegacyAddress),\n/* harmony export */   \"GasLessThanEstimate\": () => (/* binding */ GasLessThanEstimate),\n/* harmony export */   \"PasswordsDontMatchError\": () => (/* binding */ PasswordsDontMatchError),\n/* harmony export */   \"PasswordIncorrectError\": () => (/* binding */ PasswordIncorrectError),\n/* harmony export */   \"RecommendSubAccountsToEmpty\": () => (/* binding */ RecommendSubAccountsToEmpty),\n/* harmony export */   \"RecommendUndelegation\": () => (/* binding */ RecommendUndelegation),\n/* harmony export */   \"TimeoutTagged\": () => (/* binding */ TimeoutTagged),\n/* harmony export */   \"UnexpectedBootloader\": () => (/* binding */ UnexpectedBootloader),\n/* harmony export */   \"MCUNotGenuineToDashboard\": () => (/* binding */ MCUNotGenuineToDashboard),\n/* harmony export */   \"RecipientRequired\": () => (/* binding */ RecipientRequired),\n/* harmony export */   \"UnavailableTezosOriginatedAccountReceive\": () => (/* binding */ UnavailableTezosOriginatedAccountReceive),\n/* harmony export */   \"UnavailableTezosOriginatedAccountSend\": () => (/* binding */ UnavailableTezosOriginatedAccountSend),\n/* harmony export */   \"UpdateFetchFileFail\": () => (/* binding */ UpdateFetchFileFail),\n/* harmony export */   \"UpdateIncorrectHash\": () => (/* binding */ UpdateIncorrectHash),\n/* harmony export */   \"UpdateIncorrectSig\": () => (/* binding */ UpdateIncorrectSig),\n/* harmony export */   \"UpdateYourApp\": () => (/* binding */ UpdateYourApp),\n/* harmony export */   \"UserRefusedDeviceNameChange\": () => (/* binding */ UserRefusedDeviceNameChange),\n/* harmony export */   \"UserRefusedAddress\": () => (/* binding */ UserRefusedAddress),\n/* harmony export */   \"UserRefusedFirmwareUpdate\": () => (/* binding */ UserRefusedFirmwareUpdate),\n/* harmony export */   \"UserRefusedAllowManager\": () => (/* binding */ UserRefusedAllowManager),\n/* harmony export */   \"UserRefusedOnDevice\": () => (/* binding */ UserRefusedOnDevice),\n/* harmony export */   \"TransportOpenUserCancelled\": () => (/* binding */ TransportOpenUserCancelled),\n/* harmony export */   \"TransportInterfaceNotAvailable\": () => (/* binding */ TransportInterfaceNotAvailable),\n/* harmony export */   \"TransportRaceCondition\": () => (/* binding */ TransportRaceCondition),\n/* harmony export */   \"TransportWebUSBGestureRequired\": () => (/* binding */ TransportWebUSBGestureRequired),\n/* harmony export */   \"DeviceShouldStayInApp\": () => (/* binding */ DeviceShouldStayInApp),\n/* harmony export */   \"WebsocketConnectionError\": () => (/* binding */ WebsocketConnectionError),\n/* harmony export */   \"WebsocketConnectionFailed\": () => (/* binding */ WebsocketConnectionFailed),\n/* harmony export */   \"WrongDeviceForAccount\": () => (/* binding */ WrongDeviceForAccount),\n/* harmony export */   \"WrongAppForCurrency\": () => (/* binding */ WrongAppForCurrency),\n/* harmony export */   \"ETHAddressNonEIP\": () => (/* binding */ ETHAddressNonEIP),\n/* harmony export */   \"CantScanQRCode\": () => (/* binding */ CantScanQRCode),\n/* harmony export */   \"FeeNotLoaded\": () => (/* binding */ FeeNotLoaded),\n/* harmony export */   \"FeeRequired\": () => (/* binding */ FeeRequired),\n/* harmony export */   \"FeeTooHigh\": () => (/* binding */ FeeTooHigh),\n/* harmony export */   \"SyncError\": () => (/* binding */ SyncError),\n/* harmony export */   \"PairingFailed\": () => (/* binding */ PairingFailed),\n/* harmony export */   \"GenuineCheckFailed\": () => (/* binding */ GenuineCheckFailed),\n/* harmony export */   \"LedgerAPI4xx\": () => (/* binding */ LedgerAPI4xx),\n/* harmony export */   \"LedgerAPI5xx\": () => (/* binding */ LedgerAPI5xx),\n/* harmony export */   \"FirmwareOrAppUpdateRequired\": () => (/* binding */ FirmwareOrAppUpdateRequired),\n/* harmony export */   \"NoDBPathGiven\": () => (/* binding */ NoDBPathGiven),\n/* harmony export */   \"DBWrongPassword\": () => (/* binding */ DBWrongPassword),\n/* harmony export */   \"DBNotReset\": () => (/* binding */ DBNotReset),\n/* harmony export */   \"TransportError\": () => (/* binding */ TransportError),\n/* harmony export */   \"StatusCodes\": () => (/* binding */ StatusCodes),\n/* harmony export */   \"getAltStatusMessage\": () => (/* binding */ getAltStatusMessage),\n/* harmony export */   \"TransportStatusError\": () => (/* binding */ TransportStatusError)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./node_modules/@ledgerhq/errors/lib-es/helpers.js\");\n\n\nvar AccountNameRequiredError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"AccountNameRequired\");\nvar AccountNotSupported = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"AccountNotSupported\");\nvar AmountRequired = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"AmountRequired\");\nvar BluetoothRequired = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"BluetoothRequired\");\nvar BtcUnmatchedApp = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"BtcUnmatchedApp\");\nvar CantOpenDevice = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"CantOpenDevice\");\nvar CashAddrNotSupported = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"CashAddrNotSupported\");\nvar CurrencyNotSupported = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"CurrencyNotSupported\");\nvar DeviceAppVerifyNotSupported = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DeviceAppVerifyNotSupported\");\nvar DeviceGenuineSocketEarlyClose = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DeviceGenuineSocketEarlyClose\");\nvar DeviceNotGenuineError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DeviceNotGenuine\");\nvar DeviceOnDashboardExpected = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DeviceOnDashboardExpected\");\nvar DeviceOnDashboardUnexpected = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DeviceOnDashboardUnexpected\");\nvar DeviceInOSUExpected = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DeviceInOSUExpected\");\nvar DeviceHalted = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DeviceHalted\");\nvar DeviceNameInvalid = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DeviceNameInvalid\");\nvar DeviceSocketFail = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DeviceSocketFail\");\nvar DeviceSocketNoBulkStatus = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DeviceSocketNoBulkStatus\");\nvar DisconnectedDevice = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DisconnectedDevice\");\nvar DisconnectedDeviceDuringOperation = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DisconnectedDeviceDuringOperation\");\nvar EnpointConfigError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"EnpointConfig\");\nvar EthAppPleaseEnableContractData = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"EthAppPleaseEnableContractData\");\nvar FeeEstimationFailed = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"FeeEstimationFailed\");\nvar FirmwareNotRecognized = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"FirmwareNotRecognized\");\nvar HardResetFail = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"HardResetFail\");\nvar InvalidXRPTag = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"InvalidXRPTag\");\nvar InvalidAddress = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"InvalidAddress\");\nvar InvalidAddressBecauseDestinationIsAlsoSource = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"InvalidAddressBecauseDestinationIsAlsoSource\");\nvar LatestMCUInstalledError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"LatestMCUInstalledError\");\nvar UnknownMCU = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"UnknownMCU\");\nvar LedgerAPIError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"LedgerAPIError\");\nvar LedgerAPIErrorWithMessage = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"LedgerAPIErrorWithMessage\");\nvar LedgerAPINotAvailable = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"LedgerAPINotAvailable\");\nvar ManagerAppAlreadyInstalledError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"ManagerAppAlreadyInstalled\");\nvar ManagerAppRelyOnBTCError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"ManagerAppRelyOnBTC\");\nvar ManagerAppDepInstallRequired = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"ManagerAppDepInstallRequired\");\nvar ManagerAppDepUninstallRequired = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"ManagerAppDepUninstallRequired\");\nvar ManagerDeviceLockedError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"ManagerDeviceLocked\");\nvar ManagerFirmwareNotEnoughSpaceError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"ManagerFirmwareNotEnoughSpace\");\nvar ManagerNotEnoughSpaceError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"ManagerNotEnoughSpace\");\nvar ManagerUninstallBTCDep = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"ManagerUninstallBTCDep\");\nvar NetworkDown = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"NetworkDown\");\nvar NoAddressesFound = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"NoAddressesFound\");\nvar NotEnoughBalance = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"NotEnoughBalance\");\nvar NotEnoughBalanceToDelegate = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"NotEnoughBalanceToDelegate\");\nvar NotEnoughBalanceInParentAccount = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"NotEnoughBalanceInParentAccount\");\nvar NotEnoughSpendableBalance = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"NotEnoughSpendableBalance\");\nvar NotEnoughBalanceBecauseDestinationNotCreated = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"NotEnoughBalanceBecauseDestinationNotCreated\");\nvar NoAccessToCamera = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"NoAccessToCamera\");\nvar NotEnoughGas = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"NotEnoughGas\");\nvar NotSupportedLegacyAddress = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"NotSupportedLegacyAddress\");\nvar GasLessThanEstimate = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"GasLessThanEstimate\");\nvar PasswordsDontMatchError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"PasswordsDontMatch\");\nvar PasswordIncorrectError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"PasswordIncorrect\");\nvar RecommendSubAccountsToEmpty = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"RecommendSubAccountsToEmpty\");\nvar RecommendUndelegation = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"RecommendUndelegation\");\nvar TimeoutTagged = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"TimeoutTagged\");\nvar UnexpectedBootloader = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"UnexpectedBootloader\");\nvar MCUNotGenuineToDashboard = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"MCUNotGenuineToDashboard\");\nvar RecipientRequired = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"RecipientRequired\");\nvar UnavailableTezosOriginatedAccountReceive = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"UnavailableTezosOriginatedAccountReceive\");\nvar UnavailableTezosOriginatedAccountSend = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"UnavailableTezosOriginatedAccountSend\");\nvar UpdateFetchFileFail = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"UpdateFetchFileFail\");\nvar UpdateIncorrectHash = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"UpdateIncorrectHash\");\nvar UpdateIncorrectSig = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"UpdateIncorrectSig\");\nvar UpdateYourApp = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"UpdateYourApp\");\nvar UserRefusedDeviceNameChange = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"UserRefusedDeviceNameChange\");\nvar UserRefusedAddress = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"UserRefusedAddress\");\nvar UserRefusedFirmwareUpdate = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"UserRefusedFirmwareUpdate\");\nvar UserRefusedAllowManager = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"UserRefusedAllowManager\");\nvar UserRefusedOnDevice = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"UserRefusedOnDevice\"); // TODO rename because it's just for transaction refusal\nvar TransportOpenUserCancelled = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"TransportOpenUserCancelled\");\nvar TransportInterfaceNotAvailable = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"TransportInterfaceNotAvailable\");\nvar TransportRaceCondition = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"TransportRaceCondition\");\nvar TransportWebUSBGestureRequired = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"TransportWebUSBGestureRequired\");\nvar DeviceShouldStayInApp = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DeviceShouldStayInApp\");\nvar WebsocketConnectionError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"WebsocketConnectionError\");\nvar WebsocketConnectionFailed = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"WebsocketConnectionFailed\");\nvar WrongDeviceForAccount = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"WrongDeviceForAccount\");\nvar WrongAppForCurrency = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"WrongAppForCurrency\");\nvar ETHAddressNonEIP = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"ETHAddressNonEIP\");\nvar CantScanQRCode = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"CantScanQRCode\");\nvar FeeNotLoaded = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"FeeNotLoaded\");\nvar FeeRequired = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"FeeRequired\");\nvar FeeTooHigh = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"FeeTooHigh\");\nvar SyncError = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"SyncError\");\nvar PairingFailed = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"PairingFailed\");\nvar GenuineCheckFailed = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"GenuineCheckFailed\");\nvar LedgerAPI4xx = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"LedgerAPI4xx\");\nvar LedgerAPI5xx = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"LedgerAPI5xx\");\nvar FirmwareOrAppUpdateRequired = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"FirmwareOrAppUpdateRequired\");\n// db stuff, no need to translate\nvar NoDBPathGiven = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"NoDBPathGiven\");\nvar DBWrongPassword = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DBWrongPassword\");\nvar DBNotReset = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.createCustomErrorClass)(\"DBNotReset\");\n/**\n * TransportError is used for any generic transport errors.\n * e.g. Error thrown when data received by exchanges are incorrect or if exchanged failed to communicate with the device for various reason.\n */\nfunction TransportError(message, id) {\n    this.name = \"TransportError\";\n    this.message = message;\n    this.stack = new Error().stack;\n    this.id = id;\n}\nTransportError.prototype = new Error();\n(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.addCustomErrorDeserializer)(\"TransportError\", function (e) { return new TransportError(e.message, e.id); });\nvar StatusCodes = {\n    PIN_REMAINING_ATTEMPTS: 0x63c0,\n    INCORRECT_LENGTH: 0x6700,\n    MISSING_CRITICAL_PARAMETER: 0x6800,\n    COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 0x6981,\n    SECURITY_STATUS_NOT_SATISFIED: 0x6982,\n    CONDITIONS_OF_USE_NOT_SATISFIED: 0x6985,\n    INCORRECT_DATA: 0x6a80,\n    NOT_ENOUGH_MEMORY_SPACE: 0x6a84,\n    REFERENCED_DATA_NOT_FOUND: 0x6a88,\n    FILE_ALREADY_EXISTS: 0x6a89,\n    INCORRECT_P1_P2: 0x6b00,\n    INS_NOT_SUPPORTED: 0x6d00,\n    CLA_NOT_SUPPORTED: 0x6e00,\n    TECHNICAL_PROBLEM: 0x6f00,\n    OK: 0x9000,\n    MEMORY_PROBLEM: 0x9240,\n    NO_EF_SELECTED: 0x9400,\n    INVALID_OFFSET: 0x9402,\n    FILE_NOT_FOUND: 0x9404,\n    INCONSISTENT_FILE: 0x9408,\n    ALGORITHM_NOT_SUPPORTED: 0x9484,\n    INVALID_KCV: 0x9485,\n    CODE_NOT_INITIALIZED: 0x9802,\n    ACCESS_CONDITION_NOT_FULFILLED: 0x9804,\n    CONTRADICTION_SECRET_CODE_STATUS: 0x9808,\n    CONTRADICTION_INVALIDATION: 0x9810,\n    CODE_BLOCKED: 0x9840,\n    MAX_VALUE_REACHED: 0x9850,\n    GP_AUTH_FAILED: 0x6300,\n    LICENSING: 0x6f42,\n    HALTED: 0x6faa\n};\nfunction getAltStatusMessage(code) {\n    switch (code) {\n        // improve text of most common errors\n        case 0x6700:\n            return \"Incorrect length\";\n        case 0x6800:\n            return \"Missing critical parameter\";\n        case 0x6982:\n            return \"Security not satisfied (dongle locked or have invalid access rights)\";\n        case 0x6985:\n            return \"Condition of use not satisfied (denied by the user?)\";\n        case 0x6a80:\n            return \"Invalid data received\";\n        case 0x6b00:\n            return \"Invalid parameter received\";\n    }\n    if (0x6f00 <= code && code <= 0x6fff) {\n        return \"Internal error, please report\";\n    }\n}\n/**\n * Error thrown when a device returned a non success status.\n * the error.statusCode is one of the `StatusCodes` exported by this library.\n */\nfunction TransportStatusError(statusCode) {\n    this.name = \"TransportStatusError\";\n    var statusText = Object.keys(StatusCodes).find(function (k) { return StatusCodes[k] === statusCode; }) ||\n        \"UNKNOWN_ERROR\";\n    var smsg = getAltStatusMessage(statusCode) || statusText;\n    var statusCodeStr = statusCode.toString(16);\n    this.message = \"Ledger device: \" + smsg + \" (0x\" + statusCodeStr + \")\";\n    this.stack = new Error().stack;\n    this.statusCode = statusCode;\n    this.statusText = statusText;\n}\nTransportStatusError.prototype = new Error();\n(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.addCustomErrorDeserializer)(\"TransportStatusError\", function (e) { return new TransportStatusError(e.statusCode); });\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/@ledgerhq/errors/lib-es/index.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-transport-webusb/lib-es/TransportWebUSB.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-transport-webusb/lib-es/TransportWebUSB.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ledgerhq_hw_transport__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ledgerhq/hw-transport */ \"./node_modules/@ledgerhq/hw-transport/lib-es/Transport.js\");\n/* harmony import */ var _ledgerhq_devices_lib_hid_framing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ledgerhq/devices/lib/hid-framing */ \"./node_modules/@ledgerhq/devices/lib/hid-framing.js\");\n/* harmony import */ var _ledgerhq_devices__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ledgerhq/devices */ \"./node_modules/@ledgerhq/devices/lib-es/index.js\");\n/* harmony import */ var _ledgerhq_logs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ledgerhq/logs */ \"./node_modules/@ledgerhq/logs/lib-es/index.js\");\n/* harmony import */ var _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ledgerhq/errors */ \"./node_modules/@ledgerhq/errors/lib-es/index.js\");\n/* harmony import */ var _webusb__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./webusb */ \"./node_modules/@ledgerhq/hw-transport-webusb/lib-es/webusb.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n\n\nvar configurationValue = 1;\nvar endpointNumber = 3;\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nvar TransportWebUSB = /** @class */ (function (_super) {\n    __extends(TransportWebUSB, _super);\n    function TransportWebUSB(device, interfaceNumber) {\n        var _this = _super.call(this) || this;\n        _this.channel = Math.floor(Math.random() * 0xffff);\n        _this.packetSize = 64;\n        _this._disconnectEmitted = false;\n        _this._emitDisconnect = function (e) {\n            if (_this._disconnectEmitted)\n                return;\n            _this._disconnectEmitted = true;\n            _this.emit(\"disconnect\", e);\n        };\n        _this.device = device;\n        _this.interfaceNumber = interfaceNumber;\n        _this.deviceModel = (0,_ledgerhq_devices__WEBPACK_IMPORTED_MODULE_2__.identifyUSBProductId)(device.productId);\n        return _this;\n    }\n    /**\n     * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n     */\n    TransportWebUSB.request = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var device;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, (0,_webusb__WEBPACK_IMPORTED_MODULE_5__.requestLedgerDevice)()];\n                    case 1:\n                        device = _a.sent();\n                        return [2 /*return*/, TransportWebUSB.open(device)];\n                }\n            });\n        });\n    };\n    /**\n     * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n     */\n    TransportWebUSB.openConnected = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var devices;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, (0,_webusb__WEBPACK_IMPORTED_MODULE_5__.getLedgerDevices)()];\n                    case 1:\n                        devices = _a.sent();\n                        if (devices.length === 0)\n                            return [2 /*return*/, null];\n                        return [2 /*return*/, TransportWebUSB.open(devices[0])];\n                }\n            });\n        });\n    };\n    /**\n     * Create a Ledger transport with a USBDevice\n     */\n    TransportWebUSB.open = function (device) {\n        return __awaiter(this, void 0, void 0, function () {\n            var iface, interfaceNumber, e_1, transport, onDisconnect;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, device.open()];\n                    case 1:\n                        _a.sent();\n                        if (!(device.configuration === null)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, device.selectConfiguration(configurationValue)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [4 /*yield*/, gracefullyResetDevice(device)];\n                    case 4:\n                        _a.sent();\n                        iface = device.configurations[0].interfaces.find(function (_a) {\n                            var alternates = _a.alternates;\n                            return alternates.some(function (a) { return a.interfaceClass === 255; });\n                        });\n                        if (!iface) {\n                            throw new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_4__.TransportInterfaceNotAvailable(\"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\");\n                        }\n                        interfaceNumber = iface.interfaceNumber;\n                        _a.label = 5;\n                    case 5:\n                        _a.trys.push([5, 7, , 9]);\n                        return [4 /*yield*/, device.claimInterface(interfaceNumber)];\n                    case 6:\n                        _a.sent();\n                        return [3 /*break*/, 9];\n                    case 7:\n                        e_1 = _a.sent();\n                        return [4 /*yield*/, device.close()];\n                    case 8:\n                        _a.sent();\n                        throw new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_4__.TransportInterfaceNotAvailable(e_1.message);\n                    case 9:\n                        transport = new TransportWebUSB(device, interfaceNumber);\n                        onDisconnect = function (e) {\n                            if (device === e.device) {\n                                // $FlowFixMe\n                                navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n                                transport._emitDisconnect(new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_4__.DisconnectedDevice());\n                            }\n                        };\n                        // $FlowFixMe\n                        navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n                        return [2 /*return*/, transport];\n                }\n            });\n        });\n    };\n    /**\n     * Release the transport device\n     */\n    TransportWebUSB.prototype.close = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.exchangeBusyPromise];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this.device.releaseInterface(this.interfaceNumber)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, gracefullyResetDevice(this.device)];\n                    case 3:\n                        _a.sent();\n                        return [4 /*yield*/, this.device.close()];\n                    case 4:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Exchange with the device using APDU protocol.\n     * @param apdu\n     * @returns a promise of apdu response\n     */\n    TransportWebUSB.prototype.exchange = function (apdu) {\n        return __awaiter(this, void 0, void 0, function () {\n            var b;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.exchangeAtomicImpl(function () { return __awaiter(_this, void 0, void 0, function () {\n                            var _a, channel, packetSize, framing, blocks, i, result, acc, r, buffer;\n                            return __generator(this, function (_b) {\n                                switch (_b.label) {\n                                    case 0:\n                                        _a = this, channel = _a.channel, packetSize = _a.packetSize;\n                                        (0,_ledgerhq_logs__WEBPACK_IMPORTED_MODULE_3__.log)(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n                                        framing = (0,_ledgerhq_devices_lib_hid_framing__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(channel, packetSize);\n                                        blocks = framing.makeBlocks(apdu);\n                                        i = 0;\n                                        _b.label = 1;\n                                    case 1:\n                                        if (!(i < blocks.length)) return [3 /*break*/, 4];\n                                        return [4 /*yield*/, this.device.transferOut(endpointNumber, blocks[i])];\n                                    case 2:\n                                        _b.sent();\n                                        _b.label = 3;\n                                    case 3:\n                                        i++;\n                                        return [3 /*break*/, 1];\n                                    case 4:\n                                        if (!!(result = framing.getReducedResult(acc))) return [3 /*break*/, 6];\n                                        return [4 /*yield*/, this.device.transferIn(endpointNumber, packetSize)];\n                                    case 5:\n                                        r = _b.sent();\n                                        buffer = Buffer.from(r.data.buffer);\n                                        acc = framing.reduceResponse(acc, buffer);\n                                        return [3 /*break*/, 4];\n                                    case 6:\n                                        (0,_ledgerhq_logs__WEBPACK_IMPORTED_MODULE_3__.log)(\"apdu\", \"<= \" + result.toString(\"hex\"));\n                                        return [2 /*return*/, result];\n                                }\n                            });\n                        }); })[\"catch\"](function (e) {\n                            if (e && e.message && e.message.includes(\"disconnected\")) {\n                                _this._emitDisconnect(e);\n                                throw new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_4__.DisconnectedDeviceDuringOperation(e.message);\n                            }\n                            throw e;\n                        })];\n                    case 1:\n                        b = _a.sent();\n                        return [2 /*return*/, b];\n                }\n            });\n        });\n    };\n    TransportWebUSB.prototype.setScrambleKey = function () { };\n    /**\n     * Check if WebUSB transport is supported.\n     */\n    TransportWebUSB.isSupported = _webusb__WEBPACK_IMPORTED_MODULE_5__.isSupported;\n    /**\n     * List the WebUSB devices that was previously authorized by the user.\n     */\n    TransportWebUSB.list = _webusb__WEBPACK_IMPORTED_MODULE_5__.getLedgerDevices;\n    /**\n     * Actively listen to WebUSB devices and emit ONE device\n     * that was either accepted before, if not it will trigger the native permission UI.\n     *\n     * Important: it must be called in the context of a UI click!\n     */\n    TransportWebUSB.listen = function (observer) {\n        var unsubscribed = false;\n        (0,_webusb__WEBPACK_IMPORTED_MODULE_5__.getFirstLedgerDevice)().then(function (device) {\n            if (!unsubscribed) {\n                var deviceModel = (0,_ledgerhq_devices__WEBPACK_IMPORTED_MODULE_2__.identifyUSBProductId)(device.productId);\n                observer.next({\n                    type: \"add\",\n                    descriptor: device,\n                    deviceModel: deviceModel\n                });\n                observer.complete();\n            }\n        }, function (error) {\n            if (window.DOMException &&\n                error instanceof window.DOMException &&\n                error.code === 18) {\n                observer.error(new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_4__.TransportWebUSBGestureRequired(error.message));\n            }\n            else {\n                observer.error(new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_4__.TransportOpenUserCancelled(error.message));\n            }\n        });\n        function unsubscribe() {\n            unsubscribed = true;\n        }\n        return {\n            unsubscribe: unsubscribe\n        };\n    };\n    return TransportWebUSB;\n}(_ledgerhq_hw_transport__WEBPACK_IMPORTED_MODULE_0__[\"default\"]));\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TransportWebUSB);\nfunction gracefullyResetDevice(device) {\n    return __awaiter(this, void 0, void 0, function () {\n        var err_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, device.reset()];\n                case 1:\n                    _a.sent();\n                    return [3 /*break*/, 3];\n                case 2:\n                    err_1 = _a.sent();\n                    console.warn(err_1);\n                    return [3 /*break*/, 3];\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\n//# sourceMappingURL=TransportWebUSB.js.map\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/@ledgerhq/hw-transport-webusb/lib-es/TransportWebUSB.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-transport-webusb/lib-es/webusb.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-transport-webusb/lib-es/webusb.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"requestLedgerDevice\": () => (/* binding */ requestLedgerDevice),\n/* harmony export */   \"getLedgerDevices\": () => (/* binding */ getLedgerDevices),\n/* harmony export */   \"getFirstLedgerDevice\": () => (/* binding */ getFirstLedgerDevice),\n/* harmony export */   \"isSupported\": () => (/* binding */ isSupported)\n/* harmony export */ });\n/* harmony import */ var _ledgerhq_devices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ledgerhq/devices */ \"./node_modules/@ledgerhq/devices/lib-es/index.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar ledgerDevices = [\n    {\n        vendorId: _ledgerhq_devices__WEBPACK_IMPORTED_MODULE_0__.ledgerUSBVendorId\n    },\n];\nfunction requestLedgerDevice() {\n    return __awaiter(this, void 0, void 0, function () {\n        var device;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, navigator.usb.requestDevice({\n                        filters: ledgerDevices\n                    })];\n                case 1:\n                    device = _a.sent();\n                    return [2 /*return*/, device];\n            }\n        });\n    });\n}\nfunction getLedgerDevices() {\n    return __awaiter(this, void 0, void 0, function () {\n        var devices;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, navigator.usb.getDevices()];\n                case 1:\n                    devices = _a.sent();\n                    return [2 /*return*/, devices.filter(function (d) { return d.vendorId === _ledgerhq_devices__WEBPACK_IMPORTED_MODULE_0__.ledgerUSBVendorId; })];\n            }\n        });\n    });\n}\nfunction getFirstLedgerDevice() {\n    return __awaiter(this, void 0, void 0, function () {\n        var existingDevices;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, getLedgerDevices()];\n                case 1:\n                    existingDevices = _a.sent();\n                    if (existingDevices.length > 0)\n                        return [2 /*return*/, existingDevices[0]];\n                    return [2 /*return*/, requestLedgerDevice()];\n            }\n        });\n    });\n}\nvar isSupported = function () {\n    return Promise.resolve(!!navigator &&\n        !!navigator.usb &&\n        typeof navigator.usb.getDevices === \"function\");\n};\n//# sourceMappingURL=webusb.js.map\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/@ledgerhq/hw-transport-webusb/lib-es/webusb.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/hw-transport/lib-es/Transport.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ledgerhq/hw-transport/lib-es/Transport.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TransportError\": () => (/* reexport safe */ _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__.TransportError),\n/* harmony export */   \"TransportStatusError\": () => (/* reexport safe */ _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__.TransportStatusError),\n/* harmony export */   \"StatusCodes\": () => (/* reexport safe */ _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__.StatusCodes),\n/* harmony export */   \"getAltStatusMessage\": () => (/* reexport safe */ _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__.getAltStatusMessage),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ledgerhq/errors */ \"./node_modules/@ledgerhq/errors/lib-es/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __values = (undefined && undefined.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\n\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\nvar Transport = /** @class */ (function () {\n    function Transport() {\n        var _this = this;\n        this.exchangeTimeout = 30000;\n        this.unresponsiveTimeout = 15000;\n        this.deviceModel = null;\n        this._events = new (events__WEBPACK_IMPORTED_MODULE_0___default())();\n        /**\n         * wrapper on top of exchange to simplify work of the implementation.\n         * @param cla\n         * @param ins\n         * @param p1\n         * @param p2\n         * @param data\n         * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n         * @return a Promise of response buffer\n         */\n        this.send = function (cla, ins, p1, p2, data, statusList) {\n            if (data === void 0) { data = Buffer.alloc(0); }\n            if (statusList === void 0) { statusList = [_ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__.StatusCodes.OK]; }\n            return __awaiter(_this, void 0, void 0, function () {\n                var response, sw;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (data.length >= 256) {\n                                throw new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__.TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n                            }\n                            return [4 /*yield*/, this.exchange(Buffer.concat([\n                                    Buffer.from([cla, ins, p1, p2]),\n                                    Buffer.from([data.length]),\n                                    data,\n                                ]))];\n                        case 1:\n                            response = _a.sent();\n                            sw = response.readUInt16BE(response.length - 2);\n                            if (!statusList.some(function (s) { return s === sw; })) {\n                                throw new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__.TransportStatusError(sw);\n                            }\n                            return [2 /*return*/, response];\n                    }\n                });\n            });\n        };\n        this.exchangeAtomicImpl = function (f) { return __awaiter(_this, void 0, void 0, function () {\n            var resolveBusy, busyPromise, unresponsiveReached, timeout, res;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this.exchangeBusyPromise) {\n                            throw new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__.TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n                        }\n                        busyPromise = new Promise(function (r) {\n                            resolveBusy = r;\n                        });\n                        this.exchangeBusyPromise = busyPromise;\n                        unresponsiveReached = false;\n                        timeout = setTimeout(function () {\n                            unresponsiveReached = true;\n                            _this.emit(\"unresponsive\");\n                        }, this.unresponsiveTimeout);\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, , 3, 4]);\n                        return [4 /*yield*/, f()];\n                    case 2:\n                        res = _a.sent();\n                        if (unresponsiveReached) {\n                            this.emit(\"responsive\");\n                        }\n                        return [2 /*return*/, res];\n                    case 3:\n                        clearTimeout(timeout);\n                        if (resolveBusy)\n                            resolveBusy();\n                        this.exchangeBusyPromise = null;\n                        return [7 /*endfinally*/];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        }); };\n        this._appAPIlock = null;\n    }\n    /**\n     * low level api to communicate with the device\n     * This method is for implementations to implement but should not be directly called.\n     * Instead, the recommanded way is to use send() method\n     * @param apdu the data to send\n     * @return a Promise of response data\n     */\n    Transport.prototype.exchange = function (_apdu) {\n        throw new Error(\"exchange not implemented\");\n    };\n    /**\n     * set the \"scramble key\" for the next exchanges with the device.\n     * Each App can have a different scramble key and they internally will set it at instanciation.\n     * @param key the scramble key\n     */\n    Transport.prototype.setScrambleKey = function (_key) { };\n    /**\n     * close the exchange with the device.\n     * @return a Promise that ends when the transport is closed.\n     */\n    Transport.prototype.close = function () {\n        return Promise.resolve();\n    };\n    /**\n     * Listen to an event on an instance of transport.\n     * Transport implementation can have specific events. Here is the common events:\n     * * `\"disconnect\"` : triggered if Transport is disconnected\n     */\n    Transport.prototype.on = function (eventName, cb) {\n        this._events.on(eventName, cb);\n    };\n    /**\n     * Stop listening to an event on an instance of transport.\n     */\n    Transport.prototype.off = function (eventName, cb) {\n        this._events.removeListener(eventName, cb);\n    };\n    Transport.prototype.emit = function (event) {\n        var _a;\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        (_a = this._events).emit.apply(_a, __spreadArray([event], __read(args), false));\n    };\n    /**\n     * Enable or not logs of the binary exchange\n     */\n    Transport.prototype.setDebugMode = function () {\n        console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n    };\n    /**\n     * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n     */\n    Transport.prototype.setExchangeTimeout = function (exchangeTimeout) {\n        this.exchangeTimeout = exchangeTimeout;\n    };\n    /**\n     * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n     */\n    Transport.prototype.setExchangeUnresponsiveTimeout = function (unresponsiveTimeout) {\n        this.unresponsiveTimeout = unresponsiveTimeout;\n    };\n    /**\n     * create() allows to open the first descriptor available or\n     * throw if there is none or if timeout is reached.\n     * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n     * @example\n    TransportFoo.create().then(transport => ...)\n     */\n    Transport.create = function (openTimeout, listenTimeout) {\n        var _this = this;\n        if (openTimeout === void 0) { openTimeout = 3000; }\n        return new Promise(function (resolve, reject) {\n            var found = false;\n            var sub = _this.listen({\n                next: function (e) {\n                    found = true;\n                    if (sub)\n                        sub.unsubscribe();\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    _this.open(e.descriptor, openTimeout).then(resolve, reject);\n                },\n                error: function (e) {\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    reject(e);\n                },\n                complete: function () {\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    if (!found) {\n                        reject(new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__.TransportError(_this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n                    }\n                }\n            });\n            var listenTimeoutId = listenTimeout\n                ? setTimeout(function () {\n                    sub.unsubscribe();\n                    reject(new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__.TransportError(_this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n                }, listenTimeout)\n                : null;\n        });\n    };\n    Transport.prototype.decorateAppAPIMethods = function (self, methods, scrambleKey) {\n        var e_1, _a;\n        try {\n            for (var methods_1 = __values(methods), methods_1_1 = methods_1.next(); !methods_1_1.done; methods_1_1 = methods_1.next()) {\n                var methodName = methods_1_1.value;\n                self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (methods_1_1 && !methods_1_1.done && (_a = methods_1[\"return\"])) _a.call(methods_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    Transport.prototype.decorateAppAPIMethod = function (methodName, f, ctx, scrambleKey) {\n        var _this = this;\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return __awaiter(_this, void 0, void 0, function () {\n                var _appAPIlock;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            _appAPIlock = this._appAPIlock;\n                            if (_appAPIlock) {\n                                return [2 /*return*/, Promise.reject(new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__.TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"))];\n                            }\n                            _a.label = 1;\n                        case 1:\n                            _a.trys.push([1, , 3, 4]);\n                            this._appAPIlock = methodName;\n                            this.setScrambleKey(scrambleKey);\n                            return [4 /*yield*/, f.apply(ctx, args)];\n                        case 2: return [2 /*return*/, _a.sent()];\n                        case 3:\n                            this._appAPIlock = null;\n                            return [7 /*endfinally*/];\n                        case 4: return [2 /*return*/];\n                    }\n                });\n            });\n        };\n    };\n    Transport.ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n    Transport.ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n    return Transport;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Transport);\n//# sourceMappingURL=Transport.js.map\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/@ledgerhq/hw-transport/lib-es/Transport.js?");

/***/ }),

/***/ "./node_modules/@ledgerhq/logs/lib-es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@ledgerhq/logs/lib-es/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"log\": () => (/* binding */ log),\n/* harmony export */   \"listen\": () => (/* binding */ listen)\n/* harmony export */ });\nvar id = 0;\nvar subscribers = [];\n/**\n * log something\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nvar log = function (type, message, data) {\n    var obj = {\n        type: type,\n        id: String(++id),\n        date: new Date()\n    };\n    if (message)\n        obj.message = message;\n    if (data)\n        obj.data = data;\n    dispatch(obj);\n};\n/**\n * listen to logs.\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nvar listen = function (cb) {\n    subscribers.push(cb);\n    return function () {\n        var i = subscribers.indexOf(cb);\n        if (i !== -1) {\n            // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n            subscribers[i] = subscribers[subscribers.length - 1];\n            subscribers.pop();\n        }\n    };\n};\nfunction dispatch(log) {\n    for (var i = 0; i < subscribers.length; i++) {\n        try {\n            subscribers[i](log);\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n}\nif (typeof window !== \"undefined\") {\n    window.__ledgerLogsListen = listen;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/@ledgerhq/logs/lib-es/index.js?");

/***/ }),

/***/ "./node_modules/base-x/src/index.js":
/*!******************************************!*\
  !*** ./node_modules/base-x/src/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/base-x/src/index.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/bs58/index.js":
/*!************************************!*\
  !*** ./node_modules/bs58/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var basex = __webpack_require__(/*! base-x */ \"./node_modules/base-x/src/index.js\")\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/bs58/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/hash-base/index.js":
/*!*****************************************!*\
  !*** ./node_modules/hash-base/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\nvar Transform = (__webpack_require__(/*! readable-stream */ \"./node_modules/readable-stream/readable-browser.js\").Transform)\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\n\nfunction throwIfNotStringOrBuffer (val, prefix) {\n  if (!Buffer.isBuffer(val) && typeof val !== 'string') {\n    throw new TypeError(prefix + ' must be a string or a buffer')\n  }\n}\n\nfunction HashBase (blockSize) {\n  Transform.call(this)\n\n  this._block = Buffer.allocUnsafe(blockSize)\n  this._blockSize = blockSize\n  this._blockOffset = 0\n  this._length = [0, 0, 0, 0]\n\n  this._finalized = false\n}\n\ninherits(HashBase, Transform)\n\nHashBase.prototype._transform = function (chunk, encoding, callback) {\n  var error = null\n  try {\n    this.update(chunk, encoding)\n  } catch (err) {\n    error = err\n  }\n\n  callback(error)\n}\n\nHashBase.prototype._flush = function (callback) {\n  var error = null\n  try {\n    this.push(this.digest())\n  } catch (err) {\n    error = err\n  }\n\n  callback(error)\n}\n\nHashBase.prototype.update = function (data, encoding) {\n  throwIfNotStringOrBuffer(data, 'Data')\n  if (this._finalized) throw new Error('Digest already called')\n  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\n\n  // consume data\n  var block = this._block\n  var offset = 0\n  while (this._blockOffset + data.length - offset >= this._blockSize) {\n    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]\n    this._update()\n    this._blockOffset = 0\n  }\n  while (offset < data.length) block[this._blockOffset++] = data[offset++]\n\n  // update length\n  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {\n    this._length[j] += carry\n    carry = (this._length[j] / 0x0100000000) | 0\n    if (carry > 0) this._length[j] -= 0x0100000000 * carry\n  }\n\n  return this\n}\n\nHashBase.prototype._update = function () {\n  throw new Error('_update is not implemented')\n}\n\nHashBase.prototype.digest = function (encoding) {\n  if (this._finalized) throw new Error('Digest already called')\n  this._finalized = true\n\n  var digest = this._digest()\n  if (encoding !== undefined) digest = digest.toString(encoding)\n\n  // reset state\n  this._block.fill(0)\n  this._blockOffset = 0\n  for (var i = 0; i < 4; ++i) this._length[i] = 0\n\n  return digest\n}\n\nHashBase.prototype._digest = function () {\n  throw new Error('_digest is not implemented')\n}\n\nmodule.exports = HashBase\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/hash-base/index.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/ledger-liquid-lib-web/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/ledger-liquid-lib-web/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./src/ledger-liquid-lib.js */ \"./node_modules/ledger-liquid-lib-web/src/ledger-liquid-lib.js\");\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/ledger-liquid-lib-web/index.js?");

/***/ }),

/***/ "./node_modules/ledger-liquid-lib-web/src/ledger-liquid-lib.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ledger-liquid-lib-web/src/ledger-liquid-lib.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* eslint-disable require-jsdoc */\n// import * as TransportNodeHid from '@ledgerhq/hw-transport-node-hid';\n// const TransportNodeHid = require('@ledgerhq/hw-transport-node-hid').default;\nconst TransportWebUSB = (__webpack_require__(/*! @ledgerhq/hw-transport-webusb */ \"./node_modules/@ledgerhq/hw-transport-webusb/lib-es/TransportWebUSB.js\")[\"default\"]);\n// const cfdjs = require('cfd-js');\nconst Ripemd160 = __webpack_require__(/*! ripemd160 */ \"./node_modules/ripemd160/index.js\");\nconst sha = __webpack_require__(/*! sha.js */ \"./node_modules/sha.js/index.js\");\nconst base58 = __webpack_require__(/*! bs58 */ \"./node_modules/bs58/index.js\");\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction debugSendLog(funcName, buffer) {\n  // console.log(funcName, buffer.toString('hex'));\n}\n\nfunction byteToString(buffer) {\n  // return buffer.toString();\n  return (new TextDecoder).decode(buffer);\n}\n\nfunction byteToHexString(buffer) {\n  // return buffer.toString('hex');\n  return Array.from(buffer).map((v) => {\n    let str = v.toString(16);\n    if (str.length === 1) str = '0' + str;\n    return str;\n  }).join('');\n}\n\nfunction readUInt16BE(buf, offset) {\n  // return buf.readUInt16BE(offset);\n  if (buf.length <= offset + 1) {\n    throw Error('offset range error.');\n  }\n  let result = buf[offset] << 8;\n  result |= buf[offset + 1];\n  return result >>> 0;\n}\n\nfunction readUInt16LE(buf, offset) {\n  let result = 0;\n  if (buf.length <= offset + 1) {\n    throw Error('offset range error.');\n  }\n  result = buf[offset];\n  result |= buf[offset + 1] << 8;\n  return result >>> 0;\n}\n\nfunction readUInt32LE(buf, offset) {\n  let result = 0;\n  if (buf.length <= offset + 3) {\n    throw Error('offset range error.');\n  }\n  result |= buf[offset];\n  result |= buf[offset + 1] << 8;\n  result |= buf[offset + 2] << 16;\n  result |= buf[offset + 3] << 24;\n  return result >>> 0;\n}\n\nfunction readUInt64BE(buf, offset) {\n  let result = 0;\n  if (buf.length <= offset + 7) {\n    throw Error('offset range error.');\n  }\n  result |= buf[offset + 7];\n  result |= buf[offset + 6] << 8;\n  result |= buf[offset + 5] << 16;\n  result |= buf[offset + 4] << 24;\n  result |= buf[offset + 3] << 32;\n  result |= buf[offset + 2] << 40;\n  result |= buf[offset + 1] << 48;\n  result |= buf[offset] << 56;\n  return result >>> 0;\n}\n\nfunction writeUInt16LE(buf, value, offset) {\n  const wrBuf = Buffer.from([value & 0x00ff, ((value >> 8) & 0x00ff)]);\n  buf[offset] = wrBuf[0];\n  buf[offset + 1] = wrBuf[1];\n  return buf;\n}\n\nfunction writeUInt32LE(buf, value, offset) {\n  const wrBuf = Buffer.from([\n    value & 0x00ff,\n    ((value >> 8) & 0x00ff),\n    ((value >> 16) & 0x00ff),\n    ((value >> 24) & 0x00ff),\n  ]);\n  buf[offset] = wrBuf[0];\n  buf[offset + 1] = wrBuf[1];\n  buf[offset + 2] = wrBuf[2];\n  buf[offset + 3] = wrBuf[3];\n  return buf;\n}\n\nfunction writeUInt32BE(buf, value, offset) {\n  const wrBuf = Buffer.from([\n    ((value >> 24) & 0x00ff),\n    ((value >> 16) & 0x00ff),\n    ((value >> 8) & 0x00ff),\n    value & 0x00ff,\n  ]);\n  buf[offset] = wrBuf[0];\n  buf[offset + 1] = wrBuf[1];\n  buf[offset + 2] = wrBuf[2];\n  buf[offset + 3] = wrBuf[3];\n  return buf;\n}\n\nfunction hash160(buf) {\n  const sha256Hash = sha('sha256').update(buf).digest();\n  return (new Ripemd160()).update(sha256Hash).digest();\n}\n\nfunction sha256d(buf) {\n  const sha256Hash = sha('sha256').update(buf).digest();\n  return sha('sha256').update(sha256Hash).digest();\n}\n\nfunction encodeBase58Check(buf) {\n  const checksum = sha256d(buf);\n  return base58.encode(Buffer.concat([buf, checksum], buf.length + 4));\n}\n\nfunction createExtPubKey(\n    networkType, depth, childNumber, chainCode, publicKey, parentPubkey) {\n  let version = '043587cf'; // testnet\n  if ((networkType === 'mainnet') || (networkType === 'liquidv1')) {\n    version = '0488b21e'; // mainnet\n  }\n  const parentKeyBuf = Buffer.from(parentPubkey, 'hex');\n  const fingerprint = byteToHexString(hash160(parentKeyBuf).subarray(0, 4));\n  const depthStr = byteToHexString(Buffer.from([depth]));\n  let numberBuf = Buffer.alloc(4);\n  numberBuf = writeUInt32BE(numberBuf, childNumber, 0);\n  const childStr = byteToHexString(numberBuf);\n\n  const xpubHex = [\n    version, depthStr, fingerprint, childStr, chainCode, publicKey,\n  ].join('');\n  return encodeBase58Check(Buffer.from(xpubHex, 'hex'));\n}\n\nfunction readVarIntFromBuffer(buffer, startOffset) {\n  let result;\n  let size = 1;\n  if (buffer[startOffset] < 0xfd) {\n    result = buffer[startOffset];\n  } else if (buffer[startOffset] === 0xfd) {\n    result = readUInt16LE(buffer, startOffset + 1);\n    size = 3;\n  } else if (buffer[startOffset] === 0xfe) {\n    result = readUInt32LE(buffer, startOffset + 1);\n    size = 5;\n  } else {\n    const high = buffer.subarray(startOffset + 1, startOffset + 1 + 4);\n    const low = buffer.subarray(startOffset + 5, startOffset + 5 + 4);\n    result = readUInt32LE(high, 0) << 32;\n    result |= readUInt32LE(low, 0);\n    size = 9;\n  }\n  return {value: result, size: size};\n}\n\nfunction reverseBuffer(buf) {\n  const buffer = Buffer.allocUnsafe(buf.length);\n  for (let i = 0, j = buf.length - 1; i <= j; ++i, --j) {\n    buffer[i] = buf[j];\n    buffer[j] = buf[i];\n  }\n  return buffer;\n}\n\nfunction decodeRawTransaction(proposalTx) {\n  const buffer = Buffer.from(proposalTx, 'hex');\n  const txin = [];\n  const txout = [];\n  const version = readUInt32LE(buffer, 0);\n  let offset = 4;\n  // const useWitness = (buffer[offset] !== 0);\n  ++offset;\n\n  const txinVarNum = readVarIntFromBuffer(buffer, offset);\n  const txinNum = txinVarNum.value;\n  offset += txinVarNum.size;\n  for (let index = 0; index < txinNum; ++index) {\n    const txid = byteToHexString(\n        reverseBuffer(buffer.subarray(offset, offset + 32)));\n    offset += 32;\n    const utxoVout = readUInt32LE(buffer, offset);\n    offset += 4;\n    const scriptsigLenData = readVarIntFromBuffer(buffer, offset);\n    const scriptsigLen = scriptsigLenData.value;\n    offset += scriptsigLenData.size;\n    offset += scriptsigLen;\n    const sequence = readUInt32LE(buffer, offset);\n    offset += 4;\n    const txinData = {\n      txid: txid,\n      vout: utxoVout & 0x3fffffff,\n      sequence: sequence,\n    };\n    if ((utxoVout & 0x80000000) !== 0) {\n      const assetBlindingNonce = byteToHexString(\n          reverseBuffer(buffer.subarray(offset, offset + 32)));\n      offset += 32;\n      const assetEntropy = byteToHexString(\n          reverseBuffer(buffer.subarray(offset, offset + 32)));\n      offset += 32;\n      let assetAmount;\n      if (buffer[offset] <= 1) {\n        assetAmount = byteToHexString(buffer.subarray(offset, offset + 9));\n        offset += 9;\n      } else {\n        assetAmount = byteToHexString(buffer.subarray(offset, offset + 33));\n        offset += 33;\n      }\n      let token;\n      if (buffer[offset] === 0) {\n        token = '';\n        offset += 1;\n      } else if (buffer[offset] === 1) {\n        token = byteToHexString(buffer.subarray(offset, offset + 9));\n        offset += 9;\n      } else {\n        token = byteToHexString(buffer.subarray(offset, offset + 33));\n        offset += 33;\n      }\n      let issuance;\n      if (assetBlindingNonce === '0000000000000000000000000000000000000000000000000000000000000000') {\n        issuance = {\n          assetBlindingNonce: assetBlindingNonce,\n          contractHash: assetEntropy,\n          assetamountcommitment: assetAmount,\n        };\n      } else {\n        issuance = {\n          assetBlindingNonce: assetBlindingNonce,\n          assetEntropy: assetEntropy,\n          assetamountcommitment: assetAmount,\n        };\n      }\n      if (token) {\n        issuance['tokenamountcommitment'] = token;\n      }\n      txinData['issuance'] = issuance;\n    }\n    txin.push(txinData);\n  }\n\n  const txoutVarNum = readVarIntFromBuffer(buffer, offset);\n  const txoutNum = txoutVarNum.value;\n  offset += txoutVarNum.size;\n  for (let index = 0; index < txoutNum; ++index) {\n    let txoutData = {};\n    if (buffer[offset] === 0x01) {\n      // unblind\n      const asset = byteToHexString(reverseBuffer(\n          buffer.subarray(offset + 1, offset + 1 + 32)));\n      offset += 33;\n      const value = readUInt64BE(buffer, offset + 1);\n      offset += 9;\n      offset += (buffer[offset] === 0x00) ? 1 : 33; // nonce\n      const scriptPubkeyLenData = readVarIntFromBuffer(buffer, offset);\n      const scriptPubkeyLen = scriptPubkeyLenData.value;\n      offset += scriptPubkeyLenData.size;\n      const scriptPubKey = byteToHexString(buffer.subarray(\n          offset, offset + scriptPubkeyLen));\n      offset += scriptPubkeyLen;\n      txoutData = {\n        asset: asset,\n        value: value,\n        scriptPubKey: {\n          hex: scriptPubKey,\n        },\n      };\n    } else {\n      // blind\n      const assetcommitment = byteToHexString(buffer.subarray(\n          offset, offset + 33));\n      offset += 33;\n      const valuecommitment = byteToHexString(buffer.subarray(\n          offset, offset + 33));\n      offset += 33;\n      const commitmentnonce = byteToHexString(buffer.subarray(\n          offset, offset + 33));\n      offset += 33;\n      const scriptPubkeyLenData = readVarIntFromBuffer(buffer, offset);\n      const scriptPubkeyLen = scriptPubkeyLenData.value;\n      offset += scriptPubkeyLenData.size;\n      const scriptPubKey = byteToHexString(buffer.subarray(\n          offset, offset + scriptPubkeyLen));\n      offset += scriptPubkeyLen;\n      txoutData = {\n        assetcommitment: assetcommitment,\n        valuecommitment: valuecommitment,\n        commitmentnonce: commitmentnonce,\n        scriptPubKey: {\n          hex: scriptPubKey,\n        },\n      };\n    }\n    txout.push(txoutData);\n  }\n\n  const locktime = readUInt32LE(buffer, offset);\n  return {\n    version: version,\n    locktime: locktime,\n    vin: txin,\n    vout: txout,\n  };\n}\n\n// ---- ledger-liquid-lib ----\n\nfunction convertErrorCode(buf) {\n  return readUInt16BE(buf, 0);\n}\n\nfunction getVarIntBuffer(num) {\n  let buf;\n  if (num < 0xfd) {\n    buf = Buffer.from([num]);\n  } else if (num <= 0xffff) {\n    buf = Buffer.from([0xfd, 0, 0]);\n    buf = writeUInt16LE(buf, num, 1);\n  } else if (num <= 0xffffffff) {\n    buf = Buffer.from([0xfe, 0, 0, 0, 0]);\n    buf = writeUInt32LE(buf, num, 1);\n  } else {\n    buf = Buffer.from([0xff, 0, 0, 0, 0, 0, 0, 0, 0]);\n    const high = num >> 32;\n    const low = num & 0xffffffff;\n    buf = writeUInt32LE(buf, low, 1);\n    buf = writeUInt32LE(buf, high, 5);\n  }\n  return buf;\n}\n\nfunction convertValueFromAmount(amount) {\n  let value = Buffer.alloc(9);\n  value[0] = 1;\n  let high;\n  let low;\n  if (typeof amount === 'bigint') {\n    const bigHigh = (amount > BigInt(0xffffffff)) ?\n        (amount >> BigInt(32)) : BigInt(0);\n    const bigLow = amount & BigInt(0xffffffff);\n    high = Number(bigHigh);\n    low = Number(bigLow);\n  } else {\n    high = (amount > 0xffffffff) ? (amount >> 32) : 0;\n    low = amount & 0xffffffff;\n  }\n  value = writeUInt32BE(value, high, 1);\n  value = writeUInt32BE(value, low, 5);\n  return value;\n}\n\nfunction parseBip32Path(path, parent = false) {\n  let targetPath = path;\n  if (targetPath.startsWith('m/')) {\n    targetPath = targetPath.substring(2);\n  }\n  if (targetPath === '') {\n    throw new Error('empty BIP 32 path.');\n  }\n\n  const items = targetPath.split('/');\n  if (items.length > 10) {\n    throw new Error('Out of Range. Number of BIP 32 derivations to perform is up to 10.');\n  }\n  const hardendedTargets = ['\\'', 'h', 'H'];\n\n  const length = (parent) ? items.length - 1 : items.length;\n  if (length === 0) {\n    throw new Error('Out of Range. Number of BIP 32 derivations to perform is empty.');\n  }\n  let buf = Buffer.alloc(length * 4);\n  const array = [];\n  for (let idx = 0; idx < length; ++idx) {\n    let isFind = false;\n    for (let hIdx = 0; hIdx < hardendedTargets.length; ++hIdx) {\n      const hKey = hardendedTargets[hIdx];\n      const item = items[idx].split(hKey);\n      if (item.length > 1) {\n        const num = Number(item[0]);\n        if ((num === Number.NaN) || (item[1] !== '') || (item.length.length > 2)) {\n          throw new Error(`Illegal path format. [${item[0]},${item[1]}]`);\n        }\n        // const value = 0x80000000 | num;\n        const value = 2147483648 + num;\n        array.push(value);\n        buf = writeUInt32BE(buf, value, idx * 4);\n        isFind = true;\n        break;\n      }\n    }\n    if (!isFind) {\n      const num = Number(items[idx]);\n      if (num === Number.NaN) throw new Error(`Illegal path format. [${items[idx]}]`);\n      array.push(num);\n      buf = writeUInt32BE(buf, num, idx * 4);\n    }\n  }\n  // console.log('bip32 path => ', buf);\n  return {\n    buffer: buf,\n    array: array,\n  };\n}\n\nfunction splitByteArray255(byteArray) {\n  const array = [];\n  for (let offset = 0; offset < byteArray.length; offset += 255) {\n    const maxOffset = (byteArray.length > (offset + 255)) ?\n       (offset + 255) : byteArray.length;\n    const buffer = Buffer.allocUnsafe(maxOffset - offset);\n    for (let index = 0; index < (maxOffset - offset); ++index) {\n      buffer[index] = byteArray[offset + index];\n    }\n    array.push(buffer);\n    // array.push(byteArray.subarray(offset, maxOffset));\n  }\n  return array;\n}\n\n// GET WALLET PUBLIC KEY\nasync function getWalletPublicKey(\n    transport, path, option, parent = false) {\n  const CLA = 0xe0;\n  const GET_WALLET_PUBLIC_KEY = 0x40;\n  const p1 = 0;\n\n  const pathBuffer = parseBip32Path(path, parent).buffer;\n\n  const data = Buffer.concat([\n    Buffer.from([pathBuffer.length / 4]),\n    pathBuffer]);\n  debugSendLog('getWalletPublicKey send -> ', data);\n  const apdu = Buffer.concat(\n      [Buffer.from([CLA, GET_WALLET_PUBLIC_KEY, p1, option]),\n        Buffer.from([data.length]), data]);\n  const exchangeRet = await transport.exchange(apdu);\n  const result = (exchangeRet.length <= 2) ?\n      exchangeRet : exchangeRet.subarray(exchangeRet.length - 2);\n  let pubkey = '';\n  let chainCode = '';\n  let pubkeyLength = 0;\n  let addressLength = 0;\n  let address = '';\n  if (exchangeRet.length > 2) {\n    pubkeyLength = exchangeRet[0];\n    if (pubkeyLength === 65) {\n      pubkey = byteToHexString(exchangeRet.subarray(1, 66));\n    } else if (exchangeRet[0] === 33) {\n      pubkey = byteToHexString(exchangeRet.subarray(1, 34));\n    }\n    if (exchangeRet.length > (pubkeyLength + 1 + 2)) {\n      // address length\n      addressLength = exchangeRet[pubkeyLength + 1];\n      if (addressLength > 0) {\n        const addrOffset = pubkeyLength + 2;\n        address = byteToString(\n            exchangeRet.subarray(addrOffset, addrOffset + addressLength));\n      }\n    }\n    if (exchangeRet.length >= (pubkeyLength + addressLength + 2 + 32 + 2)) {\n      const codeChainOffset = pubkeyLength + addressLength + 2;\n      chainCode = byteToHexString(\n          exchangeRet.subarray(codeChainOffset, codeChainOffset + 32));\n    }\n  }\n\n  return {\n    errorCode: convertErrorCode(result),\n    pubkey: pubkey,\n    chainCode: chainCode,\n    address: address,\n  };\n}\n\n// GET COIN VERSION\nasync function getCoinVersion(transport) {\n  const CLA = 0xe0;\n  const GET_COIN_VERSION = 0x16;\n  const apdu = Buffer.from([CLA, GET_COIN_VERSION, 0, 0, 0]);\n  const exchangeRet = await transport.exchange(apdu);\n  const result = (exchangeRet.length <= 2) ? exchangeRet :\n    exchangeRet.subarray(exchangeRet.length - 2);\n  let prefixP2pkh = 0;\n  let prefixP2sh = 0;\n  let coinFamily = 0;\n  let coinName = '';\n  let coinTicker = '';\n  if (exchangeRet.length >= 9) {\n    prefixP2pkh = readUInt16BE(exchangeRet, 0);\n    prefixP2sh = readUInt16BE(exchangeRet, 2);\n    coinFamily = exchangeRet[4];\n    const coinNameLen = exchangeRet[5];\n    if (coinNameLen > 0) {\n      const coinNameArr = exchangeRet.subarray(6, 6 + coinNameLen);\n      coinName = byteToString(coinNameArr);\n    }\n    const offset = 6 + coinNameLen;\n    if (offset < exchangeRet.length) {\n      const coinTickerLen = exchangeRet[offset];\n      if (coinTickerLen > 0) {\n        const coinTickerArr = exchangeRet.subarray(\n            offset + 1, offset + 1 + coinTickerLen);\n        coinTicker = byteToString(coinTickerArr);\n      }\n    }\n  }\n  const errorCode = convertErrorCode(result);\n  return {\n    errorCode: errorCode,\n    prefixP2pkh: prefixP2pkh,\n    prefixP2sh: prefixP2sh,\n    coinFamily: coinFamily,\n    coinName: coinName,\n    coinTicker: coinTicker,\n  };\n}\n\n// GET FIRMWARE VERSION\nasync function getFirmwareVersion(transport) {\n  const CLA = 0xe0;\n  const GET_FIRMWARE_VERSION = 0xc4;\n  const apdu = Buffer.from([CLA, GET_FIRMWARE_VERSION, 0, 0, 0]);\n  const exchangeRet = await transport.exchange(apdu);\n  const result = (exchangeRet.length <= 2) ? exchangeRet :\n    exchangeRet.subarray(exchangeRet.length - 2);\n  let version = '';\n  let flag = 0;\n  let architecture = 0;\n  let major = 0;\n  let minor = 0;\n  let patch = 0;\n  let loaderMajor = 0;\n  let loaderMinor = 0;\n  if (exchangeRet.length >= 5) {\n    flag = exchangeRet[0];\n    architecture = exchangeRet[1];\n    major = exchangeRet[2];\n    minor = exchangeRet[3];\n    patch = exchangeRet[4];\n    version = `${major}.${minor}.${patch}.`;\n    if (exchangeRet.length >= 7) {\n      loaderMajor = exchangeRet[5];\n      loaderMinor = exchangeRet[6];\n    }\n  }\n  return {\n    errorCode: convertErrorCode(result),\n    versionString: version,\n    flag: flag,\n    architecture: architecture,\n    version: {\n      major: major,\n      minor: minor,\n      patch: patch,\n    },\n    loader: {\n      major: loaderMajor,\n      minor: loaderMinor,\n      patch: 0,\n    },\n  };\n}\n\nasync function liquidSetupHeadless(transport, authorizationPublicKeyHex) {\n  const ADM_CLA = 0xd0;\n  const LIQUID_SETUP_HEADLESS = 0x02;\n  const authPubkeyData = Buffer.from(authorizationPublicKeyHex, 'hex');\n  const apdu = Buffer.concat(\n      [Buffer.from([ADM_CLA, LIQUID_SETUP_HEADLESS, 0, 0]),\n        Buffer.from([authPubkeyData.length]), authPubkeyData]);\n  const exchangeRet = await transport.exchange(apdu);\n  return convertErrorCode(exchangeRet);\n}\n\nasync function sendHashInputStartCmd(transport, p1, p2, data) {\n  const CLA = 0xe0;\n  const HASH_INPUT_START = 0x44;\n  const dataArray = splitByteArray255(data);\n  let ecode = 0x9000;\n  let resultData = Buffer.alloc(0);\n  for (const index in dataArray) {\n    if (!dataArray[index]) {\n      continue;\n    }\n    const inputData = dataArray[index];\n    // Use \"==\" because the value types are different.\n    const apdu = Buffer.concat([Buffer.from([CLA, HASH_INPUT_START, p1, p2]),\n      Buffer.from([inputData.length]), inputData]);\n    debugSendLog('sendHashInputStartCmd send -> ', apdu);\n    const exchangeRet = await transport.exchange(apdu);\n    const result = (exchangeRet.length <= 2) ? exchangeRet :\n      exchangeRet.subarray(exchangeRet.length - 2);\n    resultData = (exchangeRet.length <= 2) ? Buffer.alloc(0) :\n      exchangeRet.subarray(0, exchangeRet.length - 2);\n    ecode = convertErrorCode(result);\n    if (ecode !== 0x9000) {\n      console.log('sendHashInputStartCmd Fail. ecode =', ecode);\n      break;\n    }\n  }\n  return {data: resultData, errorCode: ecode};\n}\n\nasync function sendHashInputFinalizeFullCmd(transport, p1, p2, data) {\n  // No need to divide because the transmission data unit is small.\n  const CLA = 0xe0;\n  const HASH_INPUT_FINALIZE_FULL = 0x4a;\n  if (data.length < 0xa0) {\n    const apdu = Buffer.concat(\n        [Buffer.from([CLA, HASH_INPUT_FINALIZE_FULL, p1, p2]),\n          Buffer.from([data.length]), data]);\n    debugSendLog('sendHashInputFinalizeFullCmd send -> ', apdu);\n    const exchangeRet = await transport.exchange(apdu);\n    const result = (exchangeRet.length <= 2) ? exchangeRet :\n      exchangeRet.subarray(exchangeRet.length - 2);\n    const resultData = (exchangeRet.length <= 2) ? Buffer.alloc(0) :\n      exchangeRet.subarray(0, exchangeRet.length - 2);\n    const ecode = convertErrorCode(result);\n    if (ecode != 0x9000) {\n      // console.log('sendHashInputFinalizeFullCmd recv: ', byteToHexString(exchangeRet));\n    }\n    return {data: resultData, errorCode: ecode};\n  }\n\n  const dataArray = splitByteArray190(data);\n  let ecode = 0x9000;\n  let resultData = Buffer.alloc(0);\n  for (const index in dataArray) {\n    if (!dataArray[index]) {\n      continue;\n    }\n    const inputData = dataArray[index];\n    const sendP1 = ((dataArray.length - 1) == index) ? p1 : 0x00;\n    const apdu = Buffer.concat(\n        [Buffer.from([CLA, HASH_INPUT_FINALIZE_FULL, sendP1, p2]),\n          Buffer.from([inputData.length]), inputData]);\n    debugSendLog('sendHashInputFinalizeFullCmd send -> ', apdu);\n    const exchangeRet = await transport.exchange(apdu);\n    const result = (exchangeRet.length <= 2) ? exchangeRet :\n      exchangeRet.subarray(exchangeRet.length - 2);\n    resultData = (exchangeRet.length <= 2) ? Buffer.alloc(0) :\n      exchangeRet.subarray(0, exchangeRet.length - 2);\n    ecode = convertErrorCode(result);\n    if (ecode != 0x9000) {\n      // console.log('sendHashInputFinalizeFullCmd recv: ', byteToHexString(exchangeRet));\n      break;\n    }\n  }\n  return {data: resultData, errorCode: ecode};\n}\n\nasync function sendHashSignCmd(transport, data) {\n  const CLA = 0xe0;\n  const HASH_SIGN = 0x48;\n  const apdu = Buffer.concat([Buffer.from([CLA, HASH_SIGN, 0, 0]),\n    Buffer.from([data.length]), data]);\n  debugSendLog('sendHashSignCmd send -> ', apdu);\n  const exchangeRet = await transport.exchange(apdu);\n  const result = (exchangeRet.length <= 2) ? exchangeRet :\n   exchangeRet.subarray(exchangeRet.length - 2);\n  const resultData = (exchangeRet.length <= 2) ? Buffer.alloc(0) :\n   exchangeRet.subarray(0, exchangeRet.length - 2);\n  if (exchangeRet.length > 2) {\n    // mask 0xfe\n    resultData[0] = resultData[0] & 0xfe;\n  }\n  return {\n    signature: byteToHexString(resultData),\n    errorCode: convertErrorCode(result),\n  };\n}\n\nasync function startUntrustedTransaction(transport, dectx, isContinue,\n    amountValueList, inputIndex, targetRedeemScript,\n    countupFunction = undefined) {\n  let p1 = 0;\n  const p2 = (isContinue) ? 0x80 : 0x06;\n  const txinHead = 0x03;\n\n  let version = Buffer.alloc(4);\n  version = writeUInt32LE(version, dectx.version, 0);\n  const inputNum = (inputIndex === -1) ? dectx.vin.length : 1;\n  let apdu = Buffer.concat([version, getVarIntBuffer([inputNum])]);\n  let errData = await sendHashInputStartCmd(transport, p1, p2, apdu);\n  if (errData.errorCode != 0x9000) {\n    console.log('fail sendHashInputStartCmd', errData);\n    return errData.errorCode;\n  }\n\n  p1 = 0x80;\n  // p2 = 0x00;\n  for (let idx = 0; idx < dectx.vin.length; ++idx) {\n    if ((inputIndex !== -1) && (idx !== inputIndex)) {\n      continue;\n    }\n    const header = Buffer.from([txinHead]);\n    const txid = reverseBuffer(Buffer.from(dectx.vin[idx].txid, 'hex'));\n    let vout = Buffer.alloc(4);\n    vout = writeUInt32LE(vout, dectx.vin[idx].vout, 0);\n    if ('issuance' in dectx.vin[idx]) {\n      vout[3] |= 0x80;\n    }\n    let value;\n    if ((typeof amountValueList[idx] === 'number') ||\n        (typeof amountValueList[idx] === 'bigint')) {\n      value = convertValueFromAmount(amountValueList[idx]);\n    } else {\n      value = Buffer.from(amountValueList[idx], 'hex');\n    }\n    const script = Buffer.from(targetRedeemScript, 'hex');\n    let sequence = Buffer.alloc(4);\n    sequence = writeUInt32LE(sequence, dectx.vin[idx].sequence, 0);\n    apdu = Buffer.concat([header, txid, vout, value,\n      getVarIntBuffer(script.length)]);\n    errData = await sendHashInputStartCmd(transport, p1, p2, apdu);\n    if (errData.errorCode != 0x9000) {\n      console.log('fail sendHashInputStartCmd2', errData);\n      break;\n    }\n    if (script.length !== 0) {\n      apdu = Buffer.concat([script, sequence]);\n      errData = await sendHashInputStartCmd(transport, p1, p2, apdu);\n      if (errData.errorCode != 0x9000) {\n        console.log('fail sendHashInputStartCmd2', errData);\n        break;\n      }\n    } else {\n      errData = await sendHashInputStartCmd(transport, p1, p2, sequence);\n      if (errData.errorCode != 0x9000) {\n        console.log('fail sendHashInputStartCmd2', errData);\n        break;\n      }\n    }\n\n    if ((inputIndex !== -1) && ('issuance' in dectx.vin[idx])) {\n      let data;\n      const issuance = dectx.vin[idx].issuance;\n      if ('contractHash' in issuance) {\n        data = Buffer.concat([\n          reverseBuffer(Buffer.from(issuance.assetBlindingNonce, 'hex')),\n          reverseBuffer(Buffer.from(issuance.contractHash, 'hex')),\n        ]);\n      } else {\n        data = Buffer.concat([\n          reverseBuffer(Buffer.from(issuance.assetBlindingNonce, 'hex')),\n          reverseBuffer(Buffer.from(issuance.assetEntropy, 'hex')),\n        ]);\n      }\n      if ('assetamount' in issuance) {\n        data = Buffer.concat([\n          data,\n          convertValueFromAmount(issuance.assetamount),\n        ]);\n      } else if ('assetamountcommitment' in issuance) {\n        data = Buffer.concat([\n          data,\n          Buffer.from(issuance.assetamountcommitment, 'hex'),\n        ]);\n      } else {\n        data = Buffer.concat([data, Buffer.alloc(1)]);\n      }\n      if ('tokenamount' in issuance) {\n        data = Buffer.concat([\n          data,\n          convertValueFromAmount(issuance.tokenamount),\n        ]);\n      } else if ('tokenamountcommitment' in issuance) {\n        data = Buffer.concat([\n          data,\n          Buffer.from(issuance.tokenamountcommitment, 'hex'),\n        ]);\n      } else {\n        data = Buffer.concat([data, Buffer.alloc(1)]);\n      }\n      errData = await sendHashInputStartCmd(transport, p1, p2, data);\n      if (errData.errorCode != 0x9000) {\n        console.log('fail sendHashInputStartCmd2', errData);\n        break;\n      }\n    }\n\n    if (countupFunction) countupFunction();\n  }\n  return errData.errorCode;\n}\n\nasync function liquidFinalizeInputFull(transport, dectx,\n    countupFunction = undefined) {\n  let apdu = getVarIntBuffer(dectx.vout.length);\n  let errData = await sendHashInputFinalizeFullCmd(transport, 0, 0, apdu);\n  if (errData.errorCode != 0x9000) {\n    console.log('fail sendHashInputStartCmd2', errData);\n    return errData.errorCode;\n  }\n\n  let p1 = 0;\n  for (let idx = 0; idx < dectx.vout.length; ++idx) {\n    const scriptPubkey = Buffer.from(dectx.vout[idx].scriptPubKey.hex, 'hex');\n    if ('valuecommitment' in dectx.vout[idx]) {\n      let index = Buffer.alloc(4);\n      index = writeUInt32BE(index, idx, 0);\n      apdu = Buffer.concat([\n        // Buffer.from([0xff]),   // signed data flag\n        // index,\n        Buffer.from(dectx.vout[idx].assetcommitment, 'hex'),\n        Buffer.from(dectx.vout[idx].valuecommitment, 'hex')]);\n      errData = await sendHashInputFinalizeFullCmd(transport, 0, 0, apdu);\n      if (errData.errorCode != 0x9000) {\n        console.log('liquidFinalizeInputFull ', errData);\n        break;\n      }\n      errData = await sendHashInputFinalizeFullCmd(transport, 0, 0,\n          Buffer.from(dectx.vout[idx].commitmentnonce, 'hex'));\n      if (errData.errorCode != 0x9000) {\n        console.log('liquidFinalizeInputFull ', errData);\n        break;\n      }\n      // errData = await sendHashInputFinalizeFullCmd(\n      //     transport, 0, 0, Buffer.from([0])); // confidentialKey\n      // if (errData.errorCode != 0x9000) break;\n    } else {\n      const asset = reverseBuffer(Buffer.from(dectx.vout[idx].asset, 'hex'));\n      apdu = Buffer.concat([\n        Buffer.from([1]), asset,\n        convertValueFromAmount(dectx.vout[idx].value)]);\n      errData = await sendHashInputFinalizeFullCmd(transport, 0, 0, apdu);\n      if (errData.errorCode != 0x9000) {\n        console.log('liquidFinalizeInputFull ', errData);\n        break;\n      }\n      errData = await sendHashInputFinalizeFullCmd(\n          transport, 0, 0, Buffer.from([0])); // nonce\n      if (errData.errorCode != 0x9000) {\n        console.log('liquidFinalizeInputFull ', errData);\n        break;\n      }\n      errData = await sendHashInputFinalizeFullCmd(\n          transport, 0, 0, Buffer.from([0])); // confidentialKey\n      if (errData.errorCode != 0x9000) {\n        console.log('liquidFinalizeInputFull ', errData);\n        break;\n      }\n    }\n    apdu = Buffer.concat([\n      getVarIntBuffer(scriptPubkey.length),\n      scriptPubkey]);\n    // console.log(`txout(${idx}) = `, apdu.toString('hex'));\n    p1 = ((idx + 1) == dectx.vout.length) ? 0x80 : 0x00;\n    errData = await sendHashInputFinalizeFullCmd(transport, p1, 0, apdu);\n    if (errData.errorCode != 0x9000) {\n      console.log(`liquidFinalizeInputFull = `, byteToHexString(errData.data));\n      break;\n    }\n\n    if (countupFunction) countupFunction();\n  }\n  if (errData.errorCode != 0x9000) {\n    console.log('liquidFinalizeInputFull ', errData);\n  }\n  return errData.errorCode;\n}\n\nasync function untrustedHashSign(transport, dectx, path, pin, sigHashType) {\n  const pathBuffer = parseBip32Path(path).buffer;\n  const authorization = Buffer.from(pin, 'hex');\n\n  let locktime = Buffer.alloc(4);\n  locktime = writeUInt32BE(locktime, dectx.locktime, 0);\n\n  const apdu = Buffer.concat([\n    Buffer.from([pathBuffer.length / 4]),\n    pathBuffer,\n    Buffer.from([authorization.length]),\n    authorization,\n    locktime,\n    Buffer.from([sigHashType])]);\n  // console.log('untrustedHashSign send -> ', apdu.toString('hex'));\n  const result = await sendHashSignCmd(transport, apdu);\n  if (result.errorCode != 0x9000) {\n    console.log('untrustedHashSign fail =', result);\n  }\n  return result;\n}\n\nasync function sendProvideIssuanceInformationCmd(\n    transport, data, isFinal) {\n  const CLA = 0xe0;\n  const LIQUID_PROVIDE_ISSUANCE_INFORMATION = 0xe6;\n  const dataArray = splitByteArray255(data);\n  let ecode = 0x9000;\n  for (const index in dataArray) {\n    if (!dataArray[index]) {\n      continue;\n    }\n    const inputData = dataArray[index];\n    // Use \"==\" because the value types are different.\n    const p1 = (isFinal && (dataArray.length - 1) == index) ? 0x80 : 0x00;\n    const apdu = Buffer.concat(\n        [Buffer.from([CLA, LIQUID_PROVIDE_ISSUANCE_INFORMATION, p1, 0]),\n          Buffer.from([inputData.length]), inputData]);\n    debugSendLog('liquidProvideIssuanceInformation send -> ', apdu);\n    const exchangeRet = await transport.exchange(apdu);\n    const result = (exchangeRet.length <= 2) ? exchangeRet :\n      exchangeRet.subarray(exchangeRet.length - 2);\n    ecode = convertErrorCode(result);\n    if (ecode !== 0x9000) {\n      console.log('sendProvideIssuanceInformationCmd Fail. ecode =', ecode);\n      break;\n    }\n  }\n  return ecode;\n}\n\nasync function liquidProvideIssuanceInformation(transport, dectx,\n    countupFunction = undefined) {\n  let isFind = false;\n  for (let idx = 0; idx < dectx.vin.length; ++idx) {\n    if ('issuance' in dectx.vin[idx]) {\n      isFind = true;\n      break;\n    }\n  }\n\n  let ecode = 0x9000;\n  let data;\n  if (!isFind) {\n    data = Buffer.alloc(dectx.vin.length);\n    ecode = await sendProvideIssuanceInformationCmd(\n        transport, data, true);\n    return ecode;\n  }\n\n  let allData = Buffer.alloc(0);\n  for (let idx = 0; idx < dectx.vin.length; ++idx) {\n    if ('issuance' in dectx.vin[idx]) {\n      const issuance = dectx.vin[idx].issuance;\n      if ('contractHash' in issuance) {\n        data = Buffer.concat([\n          reverseBuffer(Buffer.from(issuance.assetBlindingNonce, 'hex')),\n          reverseBuffer(Buffer.from(issuance.contractHash, 'hex')),\n        ]);\n      } else {\n        data = Buffer.concat([\n          reverseBuffer(Buffer.from(issuance.assetBlindingNonce, 'hex')),\n          reverseBuffer(Buffer.from(issuance.assetEntropy, 'hex')),\n        ]);\n      }\n      if ('assetamount' in issuance) {\n        data = Buffer.concat([\n          data,\n          convertValueFromAmount(issuance.assetamount),\n        ]);\n      } else if ('assetamountcommitment' in issuance) {\n        data = Buffer.concat([\n          data,\n          Buffer.from(issuance.assetamountcommitment, 'hex'),\n        ]);\n      } else {\n        data = Buffer.concat([data, Buffer.alloc(1)]);\n      }\n      if ('tokenamount' in issuance) {\n        data = Buffer.concat([\n          data,\n          convertValueFromAmount(issuance.tokenamount),\n        ]);\n      } else if ('tokenamountcommitment' in issuance) {\n        data = Buffer.concat([\n          data,\n          Buffer.from(issuance.tokenamountcommitment, 'hex'),\n        ]);\n      } else {\n        data = Buffer.concat([data, Buffer.alloc(1)]);\n      }\n      if (allData.length > 0) {\n        ecode = await sendProvideIssuanceInformationCmd(\n            transport, allData, false);\n        if (ecode !== 0x9000) {\n          break;\n        }\n        allData = Buffer.alloc(0);\n      }\n      ecode = await sendProvideIssuanceInformationCmd(\n          transport, data, (idx == dectx.vin.length - 1));\n      if (countupFunction) countupFunction();\n      if (ecode !== 0x9000) {\n        break;\n      }\n    } else {\n      data = Buffer.alloc(1);\n      allData = Buffer.concat([allData, data]);\n    }\n  }\n  if ((ecode === 0x9000) && (allData.length > 0)) {\n    ecode = await sendProvideIssuanceInformationCmd(\n        transport, allData, true);\n  }\n  return ecode;\n}\n\nfunction calculateGetSignatureProgress(dectx, utxoListLength) {\n  let txNum = 0;\n  let issuanceNum = 0;\n  if (dectx.vin) {\n    txNum += dectx.vin.length;\n    for (let idx = 0; idx < dectx.vin.length; ++idx) {\n      if ('issuance' in dectx.vin[idx]) {\n        ++issuanceNum;\n      }\n    }\n  }\n  if (dectx.vout) txNum += dectx.vout.length;\n  txNum += issuanceNum;\n  return {\n    utxoNum: utxoListLength,\n    txNum: txNum,\n  };\n}\n\nconst disconnectEcode = 0x6d00; // INS_NOT_SUPPORTED\nconst accessingEcode = 0x9999;\nconst accessingMsg = 'accessing other command';\n\nconst applicationType = {\n  LiquidV1: 'liquidv1',\n  Regtest: 'regtest',\n  Auto: 'auto',\n};\n\nasync function checkConnect(transport, checkAppType) {\n  // console.time('call getCoinVersion');\n  const result = await getCoinVersion(transport);\n  // console.timeEnd('call getCoinVersion');\n  // console.log('getCoinVersion =', result);\n  let connectApp = applicationType.Auto;\n  let ecode = result.errorCode;\n  if (result.errorCode === 0x9000) {\n    if ((result.prefixP2pkh === 0x39) &&\n        (result.prefixP2sh === 0x27) &&\n        (result.coinFamily === 0x01) &&\n        (result.coinName === 'Bitcoin') &&\n        (result.coinTicker === 'BTC') &&\n        (checkAppType !== applicationType.Regtest)) {\n      // liquid mainnet\n      connectApp = applicationType.LiquidV1;\n    } else if ((result.prefixP2pkh === 0xeb) &&\n        (result.prefixP2sh === 0x4b) &&\n        (result.coinFamily === 0x01) &&\n        (result.coinName === 'Bitcoin') &&\n        (result.coinTicker === 'BTC') &&\n        (checkAppType !== applicationType.LiquidV1)) {\n      // liquid testnet\n      connectApp = applicationType.Regtest;\n    } else {\n      ecode = disconnectEcode;\n    }\n  }\n  return {\n    errorCode: ecode,\n    application: connectApp,\n  };\n}\n\nfunction compressPubkey(publicKey) {\n  if (!publicKey) return '';\n  // return cfdjs.GetCompressedPubkey({pubkey: publicKey}).pubkey;\n  const pubkeyArr = Buffer.from(publicKey, 'hex');\n  if (pubkeyArr.length === 33) return publicKey;\n  const prefix = (pubkeyArr[64] & 1) !== 0 ? 0x03 : 0x02;\n  const pubkeySubArr = pubkeyArr.subarray(0, 1 + 32);\n  pubkeySubArr[0] = prefix;\n  return byteToHexString(pubkeySubArr);\n}\n\nconst sleep = (msec) => new Promise(\n    (resolve) => setTimeout(resolve, msec));\n\nconst networkTypeDefine = {\n  LiquidV1: 'liquidv1',\n  Regtest: 'regtest',\n};\n\nconst addressType = {\n  Legacy: 'legacy',\n  P2shSegwit: 'p2sh-segwit',\n  Bech32: 'bech32',\n};\n\nconst currentApplicationType = {\n  LiquidHeadless: 'Liquid Hless',\n  LiquidTestHeadless: 'Liquid Test Hless',\n  Empty: '',\n};\n\nconst getSignatureState = {\n  AnalyzeUtxo: 'analyzeUtxo',\n  InputTx: 'inputTx',\n  GetSignature: 'getSignature',\n};\n\nconst ledgerLiquidWrapper = class LedgerLiquidWrapper {\n  constructor(networkType, checkApplication = false) {\n    this.transport = undefined;\n    if ((networkType !== networkTypeDefine.LiquidV1) &&\n        (networkType !== networkTypeDefine.Regtest)) {\n      throw new Error('illegal network type.');\n    }\n    let checkAppType = applicationType.Auto;\n    if (checkApplication && checkApplication === true) {\n      if (networkType === networkTypeDefine.LiquidV1) {\n        checkAppType = applicationType.LiquidV1;\n      } else {\n        checkAppType = applicationType.Regtest;\n      }\n    }\n    this.networkType = networkType;\n    this.mainchainNetwork = (networkType === networkTypeDefine.Regtest) ?\n        'regtest' : 'mainnet';\n    this.waitForConnecting = false;\n    this.accessing = false;\n    this.connectAccessing = false;\n    this.checkAppType = checkAppType;\n    this.currentApplication = applicationType.Auto;\n    // this.currentDevicePath = '';\n    this.lastConnectTime = 0;\n    this.lastConnectCheckTime = 0;\n    // getSignature's state\n    this.getSigState = {\n      utxoNum: 0,\n      txNum: 0,\n      current: {\n        state: getSignatureState.AnalyzeUtxo,\n        utxoNum: 0,\n        txNum: 0,\n        sigNum: 0,\n      },\n      lastAccessTime: 0,\n    };\n  }\n\n  getCurrentApplication() {\n    if (this.currentApplication === applicationType.LiquidV1) {\n      return currentApplicationType.LiquidHeadless;\n    } else if (this.currentApplication === applicationType.Regtest) {\n      return currentApplicationType.LiquidTestHeadless;\n    } else {\n      return currentApplicationType.Empty;\n    }\n  }\n\n  getLastConnectionInfo() {\n    return {\n      // currentDevicePath: this.currentDevicePath,\n      lastConnectTime: this.lastConnectTime,\n    };\n  }\n\n  isAccessing() {\n    return this.accessing;\n  }\n\n  async connect(maxWaitTime = undefined, devicePath = undefined) {\n    const waitLimit = (typeof maxWaitTime === 'number') ?\n        maxWaitTime : 0;\n    const path = (typeof devicePath === 'string') ? devicePath : '';\n    console.info('connection device:', (!path) ? 'auto' : path);\n    let transport = undefined;\n    let count = (waitLimit < 1) ? 0 : 1;\n    let ecode = disconnectEcode;\n    let errMsg = 'other error';\n    let execConnect = false;\n    if (this.isAccessing()) {\n      ecode = accessingEcode;\n      errMsg = accessingMsg;\n    } else if (this.transport) {\n      const connRet = await this.isConnected();\n      ecode = connRet.errorCode;\n      if (connRet.success === false) {\n        await this.disconnect();\n        execConnect = true;\n      } else {\n        errMsg = 'already connected.';\n      }\n    } else {\n      execConnect = true;\n    }\n\n    if (execConnect) {\n      ecode = disconnectEcode;\n      try {\n        this.accessing = true;\n        this.waitForConnecting = true;\n\n        while ((count <= waitLimit) && this.waitForConnecting) {\n          try {\n            // transport = await TransportNodeHid.open(path);\n            transport = await TransportWebUSB.create();\n\n            const ret = await checkConnect(transport, this.checkAppType);\n            ecode = ret.errorCode;\n            if (ecode === 0x9000) {\n              this.transport = transport;\n              this.currentApplication = ret.application;\n              this.lastConnectCheckTime = Date.now();\n              // if (!path) {\n              //   const devList = await TransportNodeHid.list();\n              //   this.currentDevicePath = (!devList) ? '' : devList[0];\n              // } else {\n              //   this.currentDevicePath = path;\n              // }\n              this.lastConnectTime = Date.now();\n              break;\n            } else if (ecode !== disconnectEcode) {\n              console.log('illegal error. ', ecode);\n              await this.close(transport);\n              break;\n            }\n          } catch (e) {\n            // console.log(`connection fail. count=${count}`, e);\n            const errText = e.toString();\n            if (errText.indexOf('DisconnectedDevice: Cannot write to HID device') >= 0) {\n              // disconnect error\n            } else if (errText.indexOf('DisconnectedDeviceDuringOperation: Cannot write to hid device') >= 0) {\n              // disconnect error\n            } else if (errText.indexOf('TypeError: Cannot write to hid device') >= 0) {\n              // disconnect error\n            } else if (errText.indexOf('TransportError: NoDevice') >= 0) {\n              // device connect error\n            } else if (errText.indexOf('cannot open device with path') >= 0) {\n              // device connect error\n            } else if (errText.indexOf('The device was disconnected') >= 0) {\n              // device connect error\n            } else if (errText.indexOf('Must be handling a user gesture to show a permission request') >= 0) {\n              // device connect error\n            } else if (errText.indexOf('No device selected.') >= 0) {\n              // disconnect error\n            } else {\n              console.warn(e);\n              console.log(`connection fail.(exception) count=${count}`, e);\n              ecode = 0x6000;\n              errMsg = errText;\n              break;\n            }\n          }\n          if (transport) await this.close(transport);\n          transport = undefined;\n          if (count !== 0) console.info(`connection fail. count=${count}`);\n          ++count;\n          if (count < waitLimit) await sleep(1000);\n        }\n      } catch (err) {\n        // do nothing\n      } finally {\n        if (ecode === 0x9000) {\n          errMsg = '';\n        } else if (ecode === disconnectEcode) {\n          if (this.waitForConnecting) {\n            errMsg = 'connection fail.';\n          } else {\n            errMsg = 'connection cancel.';\n          }\n        }\n        this.accessing = false;\n        this.waitForConnecting = false;\n      }\n    }\n\n    return {\n      success: (ecode === 0x9000),\n      errorCode: ecode,\n      errorCodeHex: ecode.toString(16),\n      errorMessage: errMsg,\n      disconnect: (ecode === disconnectEcode),\n    };\n  }\n\n  cancelConnect() {\n    this.waitForConnecting = false;\n  }\n\n  async isConnected() {\n    let ecode = disconnectEcode;\n    let errMsg = 'other error';\n\n    if (this.accessing && this.connectAccessing) {\n      console.log('sleep start.');\n      sleep(200);\n      console.log('sleep end.');\n    }\n\n    if (this.transport === undefined) {\n      // disconnected\n    } else if (this.isAccessing()) {\n      const curTime = Date.now();\n      if (this.connectAccessing && (this.lastConnectCheckTime < curTime) &&\n          ((curTime - this.lastConnectCheckTime) > 500)) {\n        // disconnect or during connecting check.\n      } else {\n        // The connection with Ledger is valid because it is being accessed.\n        ecode = 0x9000;\n      }\n    } else {\n      try {\n        this.connectAccessing = true;\n        this.accessing = true;\n        if (this.transport !== undefined) {\n          const ret = await checkConnect(this.transport, this.checkAppType);\n          ecode = ret.errorCode;\n          if (ecode === 0x9000) {\n            this.lastConnectCheckTime = Date.now();\n          }\n        }\n      } catch (e) {\n        const errText = e.toString();\n        if (errText.indexOf('DisconnectedDevice: Cannot write to HID device') >= 0) {\n          // disconnect error\n        } else if (errText.indexOf('DisconnectedDeviceDuringOperation: Cannot write to hid device') >= 0) {\n          // disconnect error\n        } else if (errText.indexOf('TypeError: Cannot write to hid device') >= 0) {\n          // disconnect error\n        } else if (errText.indexOf('TransportError: NoDevice') >= 0) {\n          // device connect error\n        } else if (errText.indexOf('The device was disconnected.') >= 0) {\n          // device connect error\n        } else if (errText.indexOf('Must be handling a user gesture to show a permission request') >= 0) {\n          // device connect error\n        } else if (errText.indexOf('No device selected.') >= 0) {\n          // disconnect error\n        } else {\n          console.log(`connection fail.(exception) `, e);\n          ecode = 0x8000;\n          errMsg = errText;\n        }\n      } finally {\n        this.accessing = false;\n        this.connectAccessing = false;\n      }\n      if (ecode !== 0x9000) await this.disconnect();\n    }\n\n    if (ecode === 0x9000) {\n      errMsg = '';\n    } else if (ecode === disconnectEcode) {\n      errMsg = 'connection fail.';\n    }\n    return {\n      success: (ecode === 0x9000),\n      errorCode: ecode,\n      errorCodeHex: ecode.toString(16),\n      errorMessage: errMsg,\n      disconnect: (ecode === disconnectEcode),\n    };\n  }\n\n  async disconnect() {\n    if (this.transport !== undefined) {\n      try {\n        this.accessing = true;\n        const transport = this.transport;\n        this.transport = undefined;\n        await this.close(transport);\n      } catch (e) {\n        console.log(e);\n      } finally {\n        this.currentApplication = applicationType.Auto;\n        this.accessing = false;\n        // this.currentDevicePath = '';\n        this.lastConnectTime = 0;\n      }\n    }\n  }\n\n  async close(transport) {\n    if (transport !== undefined) {\n      await transport.close();\n    }\n  }\n\n  async getApplicationInfo() {\n    let result = undefined;\n    let connRet = undefined;\n    let ecode = accessingEcode;\n    let errMsg = accessingMsg;\n    if (this.isAccessing() === false) {\n      connRet = await this.isConnected();\n      ecode = connRet.errorCode;\n      errMsg = connRet.errorMessage;\n      if (connRet.success) {\n        try {\n          this.accessing = true;\n          result = await getFirmwareVersion(this.transport);\n          ecode = result.errorCode;\n          errMsg = (ecode === 0x9000) ? '' : 'other error';\n        } catch (e) {\n          console.log(e);\n          ecode = 0x8000;\n          errMsg = e.toString();\n        } finally {\n          this.accessing = false;\n        }\n      }\n    }\n    return {\n      success: (ecode === 0x9000),\n      errorCode: ecode,\n      errorCodeHex: ecode.toString(16),\n      errorMessage: errMsg,\n      disconnect: (!connRet) ? false : connRet.disconnect,\n      name: this.getCurrentApplication(),\n      flag: (!result) ? '' : result.flag,\n      architecture: (!result) ? '' : result.architecture,\n      version: (!result) ? '' : result.version,\n      loaderVersion: (!result) ? '' : result.loader,\n    };\n  }\n\n  getPublicKeyRedeemScript(publicKey) {\n    const pubkeyArr = Buffer.from(publicKey, 'hex');\n    const hash160Buf = hash160(pubkeyArr);\n    // OP_DUP OP_HASH160 <20byte-hash> OP_EQUALVERIFY OP_CHECKSIG\n    const buf = Buffer.concat([\n      Buffer.from([0x76, 0xa9, 0x14]),\n      hash160Buf,\n      Buffer.from([0x88, 0xac]),\n    ]);\n    return byteToHexString(buf);\n  }\n\n  async getWalletPublicKey(bip32Path) {\n    let result = undefined;\n    let connRet = undefined;\n    let ecode = accessingEcode;\n    let errMsg = accessingMsg;\n    if (this.isAccessing() === false) {\n      connRet = await this.isConnected();\n      ecode = connRet.errorCode;\n      errMsg = connRet.errorMessage;\n      if (connRet.success) {\n        try {\n          this.accessing = true;\n          // TODO(k-matsuzawa): notfound liquid option(0x10, 0x11)\n          const p2 = 1; // = 0x10;\n          // console.time('call getWalletPublicKey');\n          result = await getWalletPublicKey(\n              this.transport, bip32Path, p2);\n          // console.timeEnd('call getWalletPublicKey');\n          // console.log('getWalletPublicKey result =', result);\n          ecode = result.errorCode;\n          errMsg = (ecode === 0x9000) ? '' : 'other error';\n        } catch (e) {\n          console.log(e);\n          ecode = 0x8000;\n          errMsg = e.toString();\n        } finally {\n          this.accessing = false;\n        }\n      }\n    }\n    return {\n      success: (ecode === 0x9000),\n      errorCode: ecode,\n      errorCodeHex: ecode.toString(16),\n      errorMessage: errMsg,\n      disconnect: (!connRet) ? false : connRet.disconnect,\n      publicKey: (!result) ? '' : compressPubkey(result.pubkey),\n      chainCode: (!result) ? '' : result.chainCode,\n    };\n  }\n\n  async getXpubKey(bip32Path) {\n    let xpub = undefined;\n    let connRet = undefined;\n    let ecode = accessingEcode;\n    let errMsg = accessingMsg;\n    if (this.isAccessing() === false) {\n      connRet = await this.isConnected();\n      ecode = connRet.errorCode;\n      errMsg = connRet.errorMessage;\n      if (connRet.success) {\n        try {\n          this.accessing = true;\n          const p2 = 1; // = 0x10;\n          const parent = await getWalletPublicKey(\n              this.transport, bip32Path, p2, true);\n          ecode = parent.errorCode;\n          if (ecode === 0x9000) {\n            const pubkey = await getWalletPublicKey(\n                this.transport, bip32Path, p2);\n            ecode = pubkey.errorCode;\n            if (ecode === 0x9000) {\n              ecode = 0x8000;\n              const pathArr = parseBip32Path(bip32Path).array;\n              xpub = createExtPubKey(\n                  this.mainchainNetwork,\n                  pathArr.length,\n                  pathArr[pathArr.length - 1],\n                  pubkey.chainCode,\n                  compressPubkey(pubkey.pubkey),\n                  compressPubkey(parent.pubkey));\n              ecode = 0x9000;\n            }\n          }\n          errMsg = (ecode === 0x9000) ? '' : 'other error';\n        } catch (e) {\n          console.log(e);\n          ecode = 0x8000;\n          errMsg = e.toString();\n        } finally {\n          this.accessing = false;\n        }\n      }\n    }\n    return {\n      success: (ecode === 0x9000),\n      errorCode: ecode,\n      errorCodeHex: ecode.toString(16),\n      errorMessage: errMsg,\n      disconnect: (!connRet) ? false : connRet.disconnect,\n      xpubKey: (!xpub) ? '' : xpub,\n    };\n  }\n\n  async setupHeadlessAuthorization(authorizationPublicKey) {\n    let connRet = undefined;\n    let ecode = accessingEcode;\n    let errMsg = accessingMsg;\n    if (this.isAccessing() === false) {\n      connRet = await this.isConnected();\n      ecode = connRet.errorCode;\n      errMsg = connRet.errorMessage;\n      if (connRet.success) {\n        try {\n          this.accessing = true;\n          ecode = await liquidSetupHeadless(this.transport,\n              authorizationPublicKey);\n          errMsg = (ecode === 0x9000) ? '' : 'other error.';\n          if (ecode === 0x6985) {\n            errMsg = 'CONDITIONS_OF_USE_NOT_SATISFIED';\n          }\n        } catch (e) {\n          console.log(e);\n          ecode = 0x8000;\n          errMsg = e.toString();\n        } finally {\n          this.accessing = false;\n        }\n      }\n    }\n    return {\n      success: (ecode === 0x9000),\n      errorCode: ecode,\n      errorCodeHex: ecode.toString(16),\n      errorMessage: errMsg,\n      disconnect: connRet.disconnect,\n    };\n  }\n\n  //  interface WalletUtxoData extends UtxoData {\n  //    bip32Path: string; // key-1(bip32 path)\n  //    txid: string; // key(outpoint)\n  //    vout: number; // key(outpoint)\n  //    amount?: bigint | number;\n  //    valueCommitment?: string;\n  //    pubkey?: string; // pubkey.\n  //    redeemScript?: string; // redeem script.\n  //  }\n\n  decodeRawTransaction(proposalTx) {\n    return decodeRawTransaction(proposalTx);\n  }\n\n  async getSignature(proposalTransaction,\n      walletUtxoList, authorizationSignature) {\n    const signatureList = [];\n    let connRet = undefined;\n    let ecode = accessingEcode;\n    let errMsg = accessingMsg;\n    if (this.isAccessing() === false) {\n      connRet = await this.isConnected();\n      ecode = connRet.errorCode;\n      errMsg = connRet.errorMessage;\n    }\n    if (ecode === 0x9000) {\n      if (!walletUtxoList || !proposalTransaction || !authorizationSignature) {\n        ecode = 0x6a80;\n        errMsg = 'Input parameter is null or empty';\n      }\n    }\n    if (ecode !== 0x9000) {\n      return {\n        success: false,\n        errorCode: ecode,\n        errorCodeHex: ecode.toString(16),\n        errorMessage: errMsg,\n        disconnect: (!connRet) ? false : connRet.disconnect,\n        signatureList: signatureList,\n      };\n    }\n    try {\n      this.accessing = true;\n      this.getSigState.current.state = getSignatureState.AnalyzeUtxo;\n      this.getSigState.lastAccessTime = Date.now();\n\n      // const dectx = cfdjs.ElementsDecodeRawTransaction({\n      //   hex: proposalTransaction, network: this.networkType,\n      //   mainchainNetwork: this.mainchainNetwork});\n      const dectx = decodeRawTransaction(proposalTransaction);\n      // console.log('*** dectx ***\\n', JSON.stringify(dectx, null, '  '));\n      const calcInfo = calculateGetSignatureProgress(\n          dectx, walletUtxoList.length);\n      this.getSigState.utxoNum = calcInfo.utxoNum;\n      this.getSigState.txNum = calcInfo.txNum;\n      this.getSigState.current.utxoNum = 0;\n      this.getSigState.current.txNum = 0;\n      this.getSigState.current.sigNum = 0;\n      const appedTxNumFunc = () => {\n        this.getSigState.current.txNum += 1;\n        this.getSigState.lastAccessTime = Date.now();\n      };\n      const updateAccessTimeFunc = () => {\n        this.getSigState.lastAccessTime = Date.now();\n      };\n\n      const amountValueList = [];\n      const utxoList = walletUtxoList;\n      for (const txin of dectx.vin) {\n        let isFind = false;\n        for (const utxo of utxoList) {\n          if ((txin.txid === utxo.txid) && (txin.vout === utxo.vout)) {\n            let value = 0;\n            if (('valueCommitment' in utxo) && (utxo.valueCommitment) &&\n                ((utxo.valueCommitment.length === 66) ||\n                (utxo.valueCommitment.length === 18))) {\n              value = utxo.valueCommitment;\n            } else if (('amount' in utxo) && (utxo.amount)) {\n              value = utxo.amount;\n            } else {\n              throw new Error('invalid amount or valueCommitment.');\n            }\n            amountValueList.push(value);\n            isFind = true;\n            break;\n          }\n        }\n        if (!isFind) {\n          // throw new Error('txin is not in the utxo list.');\n          amountValueList.push(1); // dummy amount\n        }\n      }\n      ecode = 0x9000;\n\n      const utxoScriptList = [];\n      // Collect redeemScript before startUntrustedTransaction\n      // because you need to call getWalletPublicKey.\n      for (const utxo of walletUtxoList) {\n        let targetIndex = -1;\n        for (let index = 0; index < dectx.vin.length; ++index) {\n          if ((dectx.vin[index].txid === utxo.txid) &&\n              (dectx.vin[index].vout === utxo.vout)) {\n            targetIndex = index;\n            break;\n          }\n        }\n        if (targetIndex === -1) {\n          throw new Error('wallet utxo is not in the txin list.');\n        }\n\n        let redeemScript = '';\n        if (!utxo.descriptor && !utxo.redeemScript) {\n          // bip32 path -> pubkey -> lockingscript\n        } else if (!utxo.descriptor) {\n          redeemScript = utxo.redeemScript;\n        } else {\n          // const desc = cfdjs.ParseDescriptor({\n          //   isElements: true,\n          //   descriptor: utxo.descriptor,\n          //   network: this.networkType,\n          // });\n          // if (('scripts' in desc) && (desc.scripts.length > 0) &&\n          //      ('redeemScript' in desc.scripts[desc.scripts.length - 1])) {\n          //   redeemScript = desc.scripts[desc.scripts.length - 1].redeemScript;\n          // }\n          redeemScript = utxo.redeemScript;\n        }\n\n        if (!redeemScript) {\n          if (utxo.pubkey && (utxo.pubkey.length === 66)) {\n            redeemScript = this.getPublicKeyRedeemScript(utxo.pubkey);\n          } else {\n            const p2 = 1; // = 0x10;\n            const pubkeyRet = await getWalletPublicKey(\n                this.transport, utxo.bip32Path, p2);\n            // const pubkeyRet = await this.getWalletPublicKey(utxo.bip32Path);\n            ecode = pubkeyRet.errorCode;\n            if (ecode !== 0x9000) {\n              break;\n            }\n            const pubkey = compressPubkey(pubkeyRet.pubkey);\n            redeemScript = this.getPublicKeyRedeemScript(pubkey);\n          }\n        }\n        utxoScriptList.push({\n          redeemScript: redeemScript,\n          targetIndex: targetIndex,\n          utxo: utxo,\n        });\n        this.getSigState.current.utxoNum += 1;\n        this.getSigState.lastAccessTime = Date.now();\n      }\n\n      // console.info('amountValueList =', amountValueList);\n      if (ecode === 0x9000) {\n        this.getSigState.current.state = getSignatureState.InputTx;\n        ecode = await startUntrustedTransaction(this.transport, dectx, false,\n            amountValueList, -1, '', appedTxNumFunc);\n      }\n      if (ecode === 0x9000) {\n        ecode = await liquidFinalizeInputFull(\n            this.transport, dectx, appedTxNumFunc);\n      }\n      if (ecode === 0x9000) {\n        ecode = await liquidProvideIssuanceInformation(\n            this.transport, dectx, appedTxNumFunc);\n      }\n\n      if (ecode === 0x9000) {\n        this.getSigState.current.state = getSignatureState.GetSignature;\n        // sighashtype: 1=all only\n        const sighashtype = 1;\n        for (const utxoData of utxoScriptList) {\n          ecode = await startUntrustedTransaction(this.transport, dectx,\n              true, amountValueList, utxoData.targetIndex,\n              utxoData.redeemScript, updateAccessTimeFunc);\n          if (ecode !== 0x9000) {\n            break;\n          }\n          const signatureRet = await untrustedHashSign(this.transport, dectx,\n              utxoData.utxo.bip32Path, authorizationSignature, sighashtype);\n          ecode = signatureRet.errorCode;\n          if (ecode !== 0x9000) {\n            break;\n          }\n          // await sleep(20000);\n          signatureList.push({\n            utxoData: utxoData.utxo,\n            signature: signatureRet.signature,\n          });\n          this.getSigState.current.sigNum += 1;\n          this.getSigState.lastAccessTime = Date.now();\n        }\n      }\n      errMsg = (ecode === 0x9000) ? '' : 'other error.';\n    } catch (e) {\n      console.log(e);\n      if (ecode === 0x9000) {\n        ecode = 0x8000;\n      }\n      errMsg = e.toString();\n    } finally {\n      this.accessing = false;\n      this.getSigState.utxoNum = 0;\n      this.getSigState.txNum = 0;\n      this.getSigState.current.state = getSignatureState.AnalyzeUtxo;\n      this.getSigState.current.utxoNum = 0;\n      this.getSigState.current.txNum = 0;\n    }\n\n    return {\n      success: (ecode === 0x9000),\n      errorCode: ecode,\n      errorCodeHex: ecode.toString(16),\n      errorMessage: errMsg,\n      disconnect: false,\n      signatureList: signatureList,\n    };\n  }\n\n  getSignatureState() {\n    const timeout = 15 * 1000;\n    const result = {\n      success: true,\n      errorCode: 0x9000,\n      errorCodeHex: '',\n      errorMessage: '',\n      disconnect: false,\n      currentState: getSignatureState.AnalyzeUtxo,\n      analyzeUtxo: {current: 0, total: 0},\n      inputTx: {current: 0, total: 0},\n      getSignature: {current: 0, total: 0},\n      total: {current: 0, total: 0},\n      lastAccessTime: this.getSigState.lastAccessTime,\n    };\n    if (this.transport === undefined) {\n      result.errorCode = disconnectEcode;\n      result.disconnect = true;\n      result.errorMessage = 'connection fail.';\n    } else if (!this.accessing || (this.getSigState.utxoNum === 0)) {\n      result.errorMessage = 'not execute.';\n    } else {\n      result.currentState = this.getSigState.current.state;\n      result.analyzeUtxo.current = this.getSigState.current.utxoNum;\n      result.analyzeUtxo.total = this.getSigState.utxoNum;\n      result.inputTx.current = this.getSigState.current.txNum;\n      result.inputTx.total = this.getSigState.txNum;\n      result.getSignature.current = this.getSigState.current.sigNum;\n      result.getSignature.total = this.getSigState.utxoNum;\n      result.total.current = result.analyzeUtxo.current +\n        result.inputTx.current + result.getSignature.current;\n      result.total.total = result.analyzeUtxo.total +\n        result.inputTx.total + result.getSignature.total;\n      result.lastAccessTime = this.getSigState.lastAccessTime;\n      if (this.getSigState.lastAccessTime + timeout <= Date.now()) {\n        result.errorCode = 0x6000;\n        result.errorMessage = 'ledger call timeout';\n      }\n    }\n\n    result.success = (result.errorCode === 0x9000);\n    result.errorCodeHex = result.errorCode.toString(16);\n    return result;\n  }\n\n  calcSignatureProgress(proposalTransaction, walletUtxoList) {\n    let analyzeUtxoNum = 0;\n    let inputTxNum = 0;\n    let getSignatureNum = 0;\n    let ecode = 0x9000;\n    let errMsg = '';\n    try {\n      if (!walletUtxoList || !proposalTransaction) {\n        ecode = 0x6a80;\n        errMsg = 'Input parameter is null or empty';\n      } else {\n        // const dectx = cfdjs.ElementsDecodeRawTransaction({\n        //   hex: proposalTransaction, network: this.networkType,\n        //   mainchainNetwork: this.mainchainNetwork});\n        const dectx = decodeRawTransaction(proposalTransaction);\n        const ret = calculateGetSignatureProgress(dectx, walletUtxoList.length);\n        analyzeUtxoNum = ret.utxoNum;\n        inputTxNum = ret.txNum;\n        getSignatureNum = analyzeUtxoNum;\n      }\n    } catch (e) {\n      console.log(e);\n      ecode = 0x8000;\n      errMsg = e.toString();\n    }\n    return {\n      success: (ecode === 0x9000),\n      errorCode: ecode,\n      errorCodeHex: ecode.toString(16),\n      errorMessage: errMsg,\n      disconnect: false,\n      analyzeUtxo: {current: 0, total: analyzeUtxoNum},\n      inputTx: {current: 0, total: inputTxNum},\n      getSignature: {current: 0, total: getSignatureNum},\n      total: {current: 0, total: analyzeUtxoNum + inputTxNum + getSignatureNum},\n    };\n  }\n};\n\nmodule.exports = ledgerLiquidWrapper;\nmodule.exports.LedgerLiquidWrapper = ledgerLiquidWrapper;\nmodule.exports.NetworkType = networkTypeDefine;\nmodule.exports.NetworkType.LiquidV1 = networkTypeDefine.LiquidV1;\nmodule.exports.NetworkType.Regtest = networkTypeDefine.Regtest;\nmodule.exports.ApplicationType = currentApplicationType;\nmodule.exports.ApplicationType.LiquidHeadless =\n  currentApplicationType.LiquidHeadless;\nmodule.exports.ApplicationType.LiquidTestHeadless =\n  currentApplicationType.LiquidTestHeadless;\nmodule.exports.ApplicationType.Empty = currentApplicationType.Empty;\nmodule.exports.AddressType = addressType;\nmodule.exports.AddressType.Legacy = addressType.Legacy;\nmodule.exports.AddressType.P2shSegwit = addressType.P2shSegwit;\nmodule.exports.AddressType.Bech32 = addressType.Bech32;\nmodule.exports.GetSignatureState = getSignatureState;\nmodule.exports.GetSignatureState.AnalyzeUtxo = getSignatureState.AnalyzeUtxo;\nmodule.exports.GetSignatureState.InputTx = getSignatureState.InputTx;\nmodule.exports.GetSignatureState.GetSignature = getSignatureState.GetSignature;\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/ledger-liquid-lib-web/src/ledger-liquid-lib.js?");

/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = __webpack_require__(/*! yallist */ \"./node_modules/yallist/yallist.js\")\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/lru-cache/index.js?");

/***/ }),

/***/ "./node_modules/readable-stream/errors-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/errors-browser.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/errors-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\n\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = (__webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter);\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = (__webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer);\n\nvar OurUint8Array = __webpack_require__.g.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = __webpack_require__(/*! util */ \"?d17e\");\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ \"./node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"./node_modules/readable-stream/errors-browser.js\").codes),\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ \"./node_modules/readable-stream/lib/internal/streams/async_iterator.js\");\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = __webpack_require__(/*! ./internal/streams/from */ \"./node_modules/readable-stream/lib/internal/streams/from-browser.js\");\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\nmodule.exports = Transform;\n\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"./node_modules/readable-stream/errors-browser.js\").codes),\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = (__webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer);\n\nvar OurUint8Array = __webpack_require__.g.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"./node_modules/readable-stream/errors-browser.js\").codes),\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\"); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = __webpack_require__(/*! ./end-of-stream */ \"./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/lib/internal/streams/async_iterator.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!**************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\"),\n    Buffer = _require.Buffer;\n\nvar _require2 = __webpack_require__(/*! util */ \"?ed1b\"),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/lib/internal/streams/buffer_list.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval(" // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/lib/internal/streams/destroy.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\nvar ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(/*! ../../../errors */ \"./node_modules/readable-stream/errors-browser.js\").codes.ERR_STREAM_PREMATURE_CLOSE);\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/from-browser.js":
/*!***************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/from-browser.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/lib/internal/streams/from-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!***********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = (__webpack_require__(/*! ../../../errors */ \"./node_modules/readable-stream/errors-browser.js\").codes),\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ \"./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/lib/internal/streams/pipeline.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/state.js":
/*!********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/state.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ERR_INVALID_OPT_VALUE = (__webpack_require__(/*! ../../../errors */ \"./node_modules/readable-stream/errors-browser.js\").codes.ERR_INVALID_OPT_VALUE);\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/lib/internal/streams/state.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/lib/internal/streams/stream-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/readable-stream/lib/_stream_passthrough.js\");\nexports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ \"./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nexports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ \"./node_modules/readable-stream/lib/internal/streams/pipeline.js\");\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/readable-stream/readable-browser.js?");

/***/ }),

/***/ "./node_modules/ripemd160/index.js":
/*!*****************************************!*\
  !*** ./node_modules/ripemd160/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar Buffer = (__webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer)\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar HashBase = __webpack_require__(/*! hash-base */ \"./node_modules/hash-base/index.js\")\n\nvar ARRAY16 = new Array(16)\n\nvar zl = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n]\n\nvar zr = [\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n]\n\nvar sl = [\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n]\n\nvar sr = [\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n]\n\nvar hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]\nvar hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]\n\nfunction RIPEMD160 () {\n  HashBase.call(this, 64)\n\n  // state\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n  this._e = 0xc3d2e1f0\n}\n\ninherits(RIPEMD160, HashBase)\n\nRIPEMD160.prototype._update = function () {\n  var words = ARRAY16\n  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)\n\n  var al = this._a | 0\n  var bl = this._b | 0\n  var cl = this._c | 0\n  var dl = this._d | 0\n  var el = this._e | 0\n\n  var ar = this._a | 0\n  var br = this._b | 0\n  var cr = this._c | 0\n  var dr = this._d | 0\n  var er = this._e | 0\n\n  // computation\n  for (var i = 0; i < 80; i += 1) {\n    var tl\n    var tr\n    if (i < 16) {\n      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])\n      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])\n    } else if (i < 32) {\n      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])\n      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])\n    } else if (i < 48) {\n      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])\n      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])\n    } else if (i < 64) {\n      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])\n      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])\n    } else { // if (i<80) {\n      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])\n      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])\n    }\n\n    al = el\n    el = dl\n    dl = rotl(cl, 10)\n    cl = bl\n    bl = tl\n\n    ar = er\n    er = dr\n    dr = rotl(cr, 10)\n    cr = br\n    br = tr\n  }\n\n  // update state\n  var t = (this._b + cl + dr) | 0\n  this._b = (this._c + dl + er) | 0\n  this._c = (this._d + el + ar) | 0\n  this._d = (this._e + al + br) | 0\n  this._e = (this._a + bl + cr) | 0\n  this._a = t\n}\n\nRIPEMD160.prototype._digest = function () {\n  // create padding and handle blocks\n  this._block[this._blockOffset++] = 0x80\n  if (this._blockOffset > 56) {\n    this._block.fill(0, this._blockOffset, 64)\n    this._update()\n    this._blockOffset = 0\n  }\n\n  this._block.fill(0, this._blockOffset, 56)\n  this._block.writeUInt32LE(this._length[0], 56)\n  this._block.writeUInt32LE(this._length[1], 60)\n  this._update()\n\n  // produce result\n  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)\n  buffer.writeInt32LE(this._a, 0)\n  buffer.writeInt32LE(this._b, 4)\n  buffer.writeInt32LE(this._c, 8)\n  buffer.writeInt32LE(this._d, 12)\n  buffer.writeInt32LE(this._e, 16)\n  return buffer\n}\n\nfunction rotl (x, n) {\n  return (x << n) | (x >>> (32 - n))\n}\n\nfunction fn1 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn2 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn3 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn4 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn5 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0\n}\n\nmodule.exports = RIPEMD160\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/ripemd160/index.js?");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/semver/classes/comparator.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/classes/comparator.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    const sameDirectionIncreasing =\n      (this.operator === '>=' || this.operator === '>') &&\n      (comp.operator === '>=' || comp.operator === '>')\n    const sameDirectionDecreasing =\n      (this.operator === '<=' || this.operator === '<') &&\n      (comp.operator === '<=' || comp.operator === '<')\n    const sameSemVer = this.semver.version === comp.semver.version\n    const differentDirectionsInclusive =\n      (this.operator === '>=' || this.operator === '<=') &&\n      (comp.operator === '>=' || comp.operator === '<=')\n    const oppositeDirectionsLessThan =\n      cmp(this.semver, '<', comp.semver, options) &&\n      (this.operator === '>=' || this.operator === '>') &&\n        (comp.operator === '<=' || comp.operator === '<')\n    const oppositeDirectionsGreaterThan =\n      cmp(this.semver, '>', comp.semver, options) &&\n      (this.operator === '<=' || this.operator === '<') &&\n        (comp.operator === '>=' || comp.operator === '>')\n\n    return (\n      sameDirectionIncreasing ||\n      sameDirectionDecreasing ||\n      (sameSemVer && differentDirectionsInclusive) ||\n      oppositeDirectionsLessThan ||\n      oppositeDirectionsGreaterThan\n    )\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"./node_modules/semver/internal/parse-options.js\")\nconst {re, t} = __webpack_require__(/*! ../internal/re */ \"./node_modules/semver/internal/re.js\")\nconst cmp = __webpack_require__(/*! ../functions/cmp */ \"./node_modules/semver/functions/cmp.js\")\nconst debug = __webpack_require__(/*! ../internal/debug */ \"./node_modules/semver/internal/debug.js\")\nconst SemVer = __webpack_require__(/*! ./semver */ \"./node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ./range */ \"./node_modules/semver/classes/range.js\")\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/classes/comparator.js?");

/***/ }),

/***/ "./node_modules/semver/classes/range.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/classes/range.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.format()\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First, split based on boolean or ||\n    this.raw = range\n    this.set = range\n      .split(/\\s*\\|\\|\\s*/)\n      // map the range to a 2d array of comparators\n      .map(range => this.parseRange(range.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${range}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0)\n        this.set = [first]\n      else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.format()\n  }\n\n  format () {\n    this.range = this.set\n      .map((comps) => {\n        return comps.join(' ').trim()\n      })\n      .join('||')\n      .trim()\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    range = range.trim()\n\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts = Object.keys(this.options).join(',')\n    const memoKey = `parseRange:${memoOpts}:${range}`\n    const cached = cache.get(memoKey)\n    if (cached)\n      return cached\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range, re[t.COMPARATORTRIM])\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n\n    // normalize spaces\n    range = range.split(/\\s+/).join(' ')\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n      // in loose mode, throw out any that are not valid comparators\n      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)\n      .map(comp => new Comparator(comp, this.options))\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const l = rangeList.length\n    const rangeMap = new Map()\n    for (const comp of rangeList) {\n      if (isNullSet(comp))\n        return [comp]\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has(''))\n      rangeMap.delete('')\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\nmodule.exports = Range\n\nconst LRU = __webpack_require__(/*! lru-cache */ \"./node_modules/lru-cache/index.js\")\nconst cache = new LRU({ max: 1000 })\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"./node_modules/semver/internal/parse-options.js\")\nconst Comparator = __webpack_require__(/*! ./comparator */ \"./node_modules/semver/classes/comparator.js\")\nconst debug = __webpack_require__(/*! ../internal/debug */ \"./node_modules/semver/internal/debug.js\")\nconst SemVer = __webpack_require__(/*! ./semver */ \"./node_modules/semver/classes/semver.js\")\nconst {\n  re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace\n} = __webpack_require__(/*! ../internal/re */ \"./node_modules/semver/internal/re.js\")\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\nconst replaceTildes = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceTilde(comp, options)\n  }).join(' ')\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\nconst replaceCarets = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceCaret(comp, options)\n  }).join(' ')\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map((comp) => {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<')\n        pr = '-0'\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp.trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return (`${from} ${to}`).trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/classes/range.js?");

/***/ }),

/***/ "./node_modules/semver/classes/semver.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/classes/semver.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const debug = __webpack_require__(/*! ../internal/debug */ \"./node_modules/semver/internal/debug.js\")\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ \"./node_modules/semver/internal/constants.js\")\nconst { re, t } = __webpack_require__(/*! ../internal/re */ \"./node_modules/semver/internal/re.js\")\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"./node_modules/semver/internal/parse-options.js\")\nconst { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ \"./node_modules/semver/internal/identifiers.js\")\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier)\n        this.inc('pre', identifier)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier)\n        }\n        this.inc('pre', identifier)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre':\n        if (this.prerelease.length === 0) {\n          this.prerelease = [0]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            this.prerelease.push(0)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          if (this.prerelease[0] === identifier) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = [identifier, 0]\n            }\n          } else {\n            this.prerelease = [identifier, 0]\n          }\n        }\n        break\n\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.format()\n    this.raw = this.version\n    return this\n  }\n}\n\nmodule.exports = SemVer\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/classes/semver.js?");

/***/ }),

/***/ "./node_modules/semver/functions/clean.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/clean.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"./node_modules/semver/functions/parse.js\")\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/clean.js?");

/***/ }),

/***/ "./node_modules/semver/functions/cmp.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/cmp.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const eq = __webpack_require__(/*! ./eq */ \"./node_modules/semver/functions/eq.js\")\nconst neq = __webpack_require__(/*! ./neq */ \"./node_modules/semver/functions/neq.js\")\nconst gt = __webpack_require__(/*! ./gt */ \"./node_modules/semver/functions/gt.js\")\nconst gte = __webpack_require__(/*! ./gte */ \"./node_modules/semver/functions/gte.js\")\nconst lt = __webpack_require__(/*! ./lt */ \"./node_modules/semver/functions/lt.js\")\nconst lte = __webpack_require__(/*! ./lte */ \"./node_modules/semver/functions/lte.js\")\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/cmp.js?");

/***/ }),

/***/ "./node_modules/semver/functions/coerce.js":
/*!*************************************************!*\
  !*** ./node_modules/semver/functions/coerce.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst parse = __webpack_require__(/*! ./parse */ \"./node_modules/semver/functions/parse.js\")\nconst {re, t} = __webpack_require__(/*! ../internal/re */ \"./node_modules/semver/internal/re.js\")\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null)\n    return null\n\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)\n}\nmodule.exports = coerce\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/coerce.js?");

/***/ }),

/***/ "./node_modules/semver/functions/compare-build.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-build.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/compare-build.js?");

/***/ }),

/***/ "./node_modules/semver/functions/compare-loose.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-loose.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/compare-loose.js?");

/***/ }),

/***/ "./node_modules/semver/functions/compare.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/functions/compare.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/compare.js?");

/***/ }),

/***/ "./node_modules/semver/functions/diff.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/diff.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"./node_modules/semver/functions/parse.js\")\nconst eq = __webpack_require__(/*! ./eq */ \"./node_modules/semver/functions/eq.js\")\n\nconst diff = (version1, version2) => {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    const v1 = parse(version1)\n    const v2 = parse(version2)\n    const hasPre = v1.prerelease.length || v2.prerelease.length\n    const prefix = hasPre ? 'pre' : ''\n    const defaultResult = hasPre ? 'prerelease' : ''\n    for (const key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\nmodule.exports = diff\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/diff.js?");

/***/ }),

/***/ "./node_modules/semver/functions/eq.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/eq.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/eq.js?");

/***/ }),

/***/ "./node_modules/semver/functions/gt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/gt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/gt.js?");

/***/ }),

/***/ "./node_modules/semver/functions/gte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/gte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/gte.js?");

/***/ }),

/***/ "./node_modules/semver/functions/inc.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/inc.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\n\nconst inc = (version, release, options, identifier) => {\n  if (typeof (options) === 'string') {\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(version, options).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/inc.js?");

/***/ }),

/***/ "./node_modules/semver/functions/lt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/lt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/lt.js?");

/***/ }),

/***/ "./node_modules/semver/functions/lte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/lte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/lte.js?");

/***/ }),

/***/ "./node_modules/semver/functions/major.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/major.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/major.js?");

/***/ }),

/***/ "./node_modules/semver/functions/minor.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/minor.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/minor.js?");

/***/ }),

/***/ "./node_modules/semver/functions/neq.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/neq.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/neq.js?");

/***/ }),

/***/ "./node_modules/semver/functions/parse.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/parse.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {MAX_LENGTH} = __webpack_require__(/*! ../internal/constants */ \"./node_modules/semver/internal/constants.js\")\nconst { re, t } = __webpack_require__(/*! ../internal/re */ \"./node_modules/semver/internal/re.js\")\nconst SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\n\nconst parseOptions = __webpack_require__(/*! ../internal/parse-options */ \"./node_modules/semver/internal/parse-options.js\")\nconst parse = (version, options) => {\n  options = parseOptions(options)\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  const r = options.loose ? re[t.LOOSE] : re[t.FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nmodule.exports = parse\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/parse.js?");

/***/ }),

/***/ "./node_modules/semver/functions/patch.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/patch.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/patch.js?");

/***/ }),

/***/ "./node_modules/semver/functions/prerelease.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/functions/prerelease.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"./node_modules/semver/functions/parse.js\")\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/prerelease.js?");

/***/ }),

/***/ "./node_modules/semver/functions/rcompare.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/functions/rcompare.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compare = __webpack_require__(/*! ./compare */ \"./node_modules/semver/functions/compare.js\")\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/rcompare.js?");

/***/ }),

/***/ "./node_modules/semver/functions/rsort.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/rsort.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compareBuild = __webpack_require__(/*! ./compare-build */ \"./node_modules/semver/functions/compare-build.js\")\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/rsort.js?");

/***/ }),

/***/ "./node_modules/semver/functions/satisfies.js":
/*!****************************************************!*\
  !*** ./node_modules/semver/functions/satisfies.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/satisfies.js?");

/***/ }),

/***/ "./node_modules/semver/functions/sort.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/sort.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const compareBuild = __webpack_require__(/*! ./compare-build */ \"./node_modules/semver/functions/compare-build.js\")\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/sort.js?");

/***/ }),

/***/ "./node_modules/semver/functions/valid.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/valid.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const parse = __webpack_require__(/*! ./parse */ \"./node_modules/semver/functions/parse.js\")\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/functions/valid.js?");

/***/ }),

/***/ "./node_modules/semver/index.js":
/*!**************************************!*\
  !*** ./node_modules/semver/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// just pre-load all the stuff that index.js lazily exports\nconst internalRe = __webpack_require__(/*! ./internal/re */ \"./node_modules/semver/internal/re.js\")\nmodule.exports = {\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: (__webpack_require__(/*! ./internal/constants */ \"./node_modules/semver/internal/constants.js\").SEMVER_SPEC_VERSION),\n  SemVer: __webpack_require__(/*! ./classes/semver */ \"./node_modules/semver/classes/semver.js\"),\n  compareIdentifiers: (__webpack_require__(/*! ./internal/identifiers */ \"./node_modules/semver/internal/identifiers.js\").compareIdentifiers),\n  rcompareIdentifiers: (__webpack_require__(/*! ./internal/identifiers */ \"./node_modules/semver/internal/identifiers.js\").rcompareIdentifiers),\n  parse: __webpack_require__(/*! ./functions/parse */ \"./node_modules/semver/functions/parse.js\"),\n  valid: __webpack_require__(/*! ./functions/valid */ \"./node_modules/semver/functions/valid.js\"),\n  clean: __webpack_require__(/*! ./functions/clean */ \"./node_modules/semver/functions/clean.js\"),\n  inc: __webpack_require__(/*! ./functions/inc */ \"./node_modules/semver/functions/inc.js\"),\n  diff: __webpack_require__(/*! ./functions/diff */ \"./node_modules/semver/functions/diff.js\"),\n  major: __webpack_require__(/*! ./functions/major */ \"./node_modules/semver/functions/major.js\"),\n  minor: __webpack_require__(/*! ./functions/minor */ \"./node_modules/semver/functions/minor.js\"),\n  patch: __webpack_require__(/*! ./functions/patch */ \"./node_modules/semver/functions/patch.js\"),\n  prerelease: __webpack_require__(/*! ./functions/prerelease */ \"./node_modules/semver/functions/prerelease.js\"),\n  compare: __webpack_require__(/*! ./functions/compare */ \"./node_modules/semver/functions/compare.js\"),\n  rcompare: __webpack_require__(/*! ./functions/rcompare */ \"./node_modules/semver/functions/rcompare.js\"),\n  compareLoose: __webpack_require__(/*! ./functions/compare-loose */ \"./node_modules/semver/functions/compare-loose.js\"),\n  compareBuild: __webpack_require__(/*! ./functions/compare-build */ \"./node_modules/semver/functions/compare-build.js\"),\n  sort: __webpack_require__(/*! ./functions/sort */ \"./node_modules/semver/functions/sort.js\"),\n  rsort: __webpack_require__(/*! ./functions/rsort */ \"./node_modules/semver/functions/rsort.js\"),\n  gt: __webpack_require__(/*! ./functions/gt */ \"./node_modules/semver/functions/gt.js\"),\n  lt: __webpack_require__(/*! ./functions/lt */ \"./node_modules/semver/functions/lt.js\"),\n  eq: __webpack_require__(/*! ./functions/eq */ \"./node_modules/semver/functions/eq.js\"),\n  neq: __webpack_require__(/*! ./functions/neq */ \"./node_modules/semver/functions/neq.js\"),\n  gte: __webpack_require__(/*! ./functions/gte */ \"./node_modules/semver/functions/gte.js\"),\n  lte: __webpack_require__(/*! ./functions/lte */ \"./node_modules/semver/functions/lte.js\"),\n  cmp: __webpack_require__(/*! ./functions/cmp */ \"./node_modules/semver/functions/cmp.js\"),\n  coerce: __webpack_require__(/*! ./functions/coerce */ \"./node_modules/semver/functions/coerce.js\"),\n  Comparator: __webpack_require__(/*! ./classes/comparator */ \"./node_modules/semver/classes/comparator.js\"),\n  Range: __webpack_require__(/*! ./classes/range */ \"./node_modules/semver/classes/range.js\"),\n  satisfies: __webpack_require__(/*! ./functions/satisfies */ \"./node_modules/semver/functions/satisfies.js\"),\n  toComparators: __webpack_require__(/*! ./ranges/to-comparators */ \"./node_modules/semver/ranges/to-comparators.js\"),\n  maxSatisfying: __webpack_require__(/*! ./ranges/max-satisfying */ \"./node_modules/semver/ranges/max-satisfying.js\"),\n  minSatisfying: __webpack_require__(/*! ./ranges/min-satisfying */ \"./node_modules/semver/ranges/min-satisfying.js\"),\n  minVersion: __webpack_require__(/*! ./ranges/min-version */ \"./node_modules/semver/ranges/min-version.js\"),\n  validRange: __webpack_require__(/*! ./ranges/valid */ \"./node_modules/semver/ranges/valid.js\"),\n  outside: __webpack_require__(/*! ./ranges/outside */ \"./node_modules/semver/ranges/outside.js\"),\n  gtr: __webpack_require__(/*! ./ranges/gtr */ \"./node_modules/semver/ranges/gtr.js\"),\n  ltr: __webpack_require__(/*! ./ranges/ltr */ \"./node_modules/semver/ranges/ltr.js\"),\n  intersects: __webpack_require__(/*! ./ranges/intersects */ \"./node_modules/semver/ranges/intersects.js\"),\n  simplifyRange: __webpack_require__(/*! ./ranges/simplify */ \"./node_modules/semver/ranges/simplify.js\"),\n  subset: __webpack_require__(/*! ./ranges/subset */ \"./node_modules/semver/ranges/subset.js\"),\n}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/index.js?");

/***/ }),

/***/ "./node_modules/semver/internal/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/internal/constants.js ***!
  \***************************************************/
/***/ ((module) => {

eval("// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\nmodule.exports = {\n  SEMVER_SPEC_VERSION,\n  MAX_LENGTH,\n  MAX_SAFE_INTEGER,\n  MAX_SAFE_COMPONENT_LENGTH\n}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/internal/constants.js?");

/***/ }),

/***/ "./node_modules/semver/internal/debug.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/internal/debug.js ***!
  \***********************************************/
/***/ ((module) => {

eval("const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/internal/debug.js?");

/***/ }),

/***/ "./node_modules/semver/internal/identifiers.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/internal/identifiers.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers\n}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/internal/identifiers.js?");

/***/ }),

/***/ "./node_modules/semver/internal/parse-options.js":
/*!*******************************************************!*\
  !*** ./node_modules/semver/internal/parse-options.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("// parse out just the options we care about so we always get a consistent\n// obj with keys in a consistent order.\nconst opts = ['includePrerelease', 'loose', 'rtl']\nconst parseOptions = options =>\n  !options ? {}\n  : typeof options !== 'object' ? { loose: true }\n  : opts.filter(k => options[k]).reduce((options, k) => {\n    options[k] = true\n    return options\n  }, {})\nmodule.exports = parseOptions\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/internal/parse-options.js?");

/***/ }),

/***/ "./node_modules/semver/internal/re.js":
/*!********************************************!*\
  !*** ./node_modules/semver/internal/re.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(/*! ./constants */ \"./node_modules/semver/internal/constants.js\")\nconst debug = __webpack_require__(/*! ./debug */ \"./node_modules/semver/internal/debug.js\")\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst createToken = (name, value, isGlobal) => {\n  const index = R++\n  debug(index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*')\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCE', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\.0\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\.0\\.0-0\\\\s*$')\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/internal/re.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/gtr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/gtr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Determine if version is greater than all the versions possible in the range.\nconst outside = __webpack_require__(/*! ./outside */ \"./node_modules/semver/ranges/outside.js\")\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/ranges/gtr.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/intersects.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/ranges/intersects.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\nmodule.exports = intersects\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/ranges/intersects.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/ltr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/ltr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const outside = __webpack_require__(/*! ./outside */ \"./node_modules/semver/ranges/outside.js\")\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/ranges/ltr.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/max-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/max-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/ranges/max-satisfying.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/min-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/min-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/ranges/min-satisfying.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/min-version.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/ranges/min-version.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\nconst gt = __webpack_require__(/*! ../functions/gt */ \"./node_modules/semver/functions/gt.js\")\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin)))\n      minver = setMin\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/ranges/min-version.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/outside.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/ranges/outside.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const SemVer = __webpack_require__(/*! ../classes/semver */ \"./node_modules/semver/classes/semver.js\")\nconst Comparator = __webpack_require__(/*! ../classes/comparator */ \"./node_modules/semver/classes/comparator.js\")\nconst {ANY} = Comparator\nconst Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\nconst satisfies = __webpack_require__(/*! ../functions/satisfies */ \"./node_modules/semver/functions/satisfies.js\")\nconst gt = __webpack_require__(/*! ../functions/gt */ \"./node_modules/semver/functions/gt.js\")\nconst lt = __webpack_require__(/*! ../functions/lt */ \"./node_modules/semver/functions/lt.js\")\nconst lte = __webpack_require__(/*! ../functions/lte */ \"./node_modules/semver/functions/lte.js\")\nconst gte = __webpack_require__(/*! ../functions/gte */ \"./node_modules/semver/functions/gte.js\")\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/ranges/outside.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/simplify.js":
/*!************************************************!*\
  !*** ./node_modules/semver/ranges/simplify.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"./node_modules/semver/functions/satisfies.js\")\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"./node_modules/semver/functions/compare.js\")\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let min = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!min)\n        min = version\n    } else {\n      if (prev) {\n        set.push([min, prev])\n      }\n      prev = null\n      min = null\n    }\n  }\n  if (min)\n    set.push([min, null])\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max)\n      ranges.push(min)\n    else if (!max && min === v[0])\n      ranges.push('*')\n    else if (!max)\n      ranges.push(`>=${min}`)\n    else if (min === v[0])\n      ranges.push(`<=${max}`)\n    else\n      ranges.push(`${min} - ${max}`)\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/ranges/simplify.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/subset.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/ranges/subset.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range.js */ \"./node_modules/semver/classes/range.js\")\nconst Comparator = __webpack_require__(/*! ../classes/comparator.js */ \"./node_modules/semver/classes/comparator.js\")\nconst { ANY } = Comparator\nconst satisfies = __webpack_require__(/*! ../functions/satisfies.js */ \"./node_modules/semver/functions/satisfies.js\")\nconst compare = __webpack_require__(/*! ../functions/compare.js */ \"./node_modules/semver/functions/compare.js\")\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom)\n    return true\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub)\n        continue OUTER\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull)\n      return false\n  }\n  return true\n}\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom)\n    return true\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY)\n      return true\n    else if (options.includePrerelease)\n      sub = [ new Comparator('>=0.0.0-0') ]\n    else\n      sub = [ new Comparator('>=0.0.0') ]\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease)\n      return true\n    else\n      dom = [ new Comparator('>=0.0.0') ]\n  }\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=')\n      gt = higherGT(gt, c, options)\n    else if (c.operator === '<' || c.operator === '<=')\n      lt = lowerLT(lt, c, options)\n    else\n      eqSet.add(c.semver)\n  }\n\n  if (eqSet.size > 1)\n    return null\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0)\n      return null\n    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))\n      return null\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options))\n      return null\n\n    if (lt && !satisfies(eq, String(lt), options))\n      return null\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options))\n        return false\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n  let needDomLTPre = lt &&\n    !options.includePrerelease &&\n    lt.semver.prerelease.length ? lt.semver : false\n  let needDomGTPre = gt &&\n    !options.includePrerelease &&\n    gt.semver.prerelease.length ? gt.semver : false\n  // exception: <1.2.3-0 is the same as <1.2.3\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomGTPre.major &&\n            c.semver.minor === needDomGTPre.minor &&\n            c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false\n        }\n      }\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt)\n          return false\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))\n        return false\n    }\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomLTPre.major &&\n            c.semver.minor === needDomLTPre.minor &&\n            c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false\n        }\n      }\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt)\n          return false\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))\n        return false\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0)\n      return false\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0)\n    return false\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0)\n    return false\n\n  // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n  if (needDomGTPre || needDomLTPre)\n    return false\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/ranges/subset.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/to-comparators.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/to-comparators.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/ranges/to-comparators.js?");

/***/ }),

/***/ "./node_modules/semver/ranges/valid.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/ranges/valid.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Range = __webpack_require__(/*! ../classes/range */ \"./node_modules/semver/classes/range.js\")\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/semver/ranges/valid.js?");

/***/ }),

/***/ "./node_modules/sha.js/hash.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\n\n// prototype class for hash functions\nfunction Hash (blockSize, finalSize) {\n  this._block = Buffer.alloc(blockSize)\n  this._finalSize = finalSize\n  this._blockSize = blockSize\n  this._len = 0\n}\n\nHash.prototype.update = function (data, enc) {\n  if (typeof data === 'string') {\n    enc = enc || 'utf8'\n    data = Buffer.from(data, enc)\n  }\n\n  var block = this._block\n  var blockSize = this._blockSize\n  var length = data.length\n  var accum = this._len\n\n  for (var offset = 0; offset < length;) {\n    var assigned = accum % blockSize\n    var remainder = Math.min(length - offset, blockSize - assigned)\n\n    for (var i = 0; i < remainder; i++) {\n      block[assigned + i] = data[offset + i]\n    }\n\n    accum += remainder\n    offset += remainder\n\n    if ((accum % blockSize) === 0) {\n      this._update(block)\n    }\n  }\n\n  this._len += length\n  return this\n}\n\nHash.prototype.digest = function (enc) {\n  var rem = this._len % this._blockSize\n\n  this._block[rem] = 0x80\n\n  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest\n  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize\n  this._block.fill(0, rem + 1)\n\n  if (rem >= this._finalSize) {\n    this._update(this._block)\n    this._block.fill(0)\n  }\n\n  var bits = this._len * 8\n\n  // uint32\n  if (bits <= 0xffffffff) {\n    this._block.writeUInt32BE(bits, this._blockSize - 4)\n\n  // uint64\n  } else {\n    var lowBits = (bits & 0xffffffff) >>> 0\n    var highBits = (bits - lowBits) / 0x100000000\n\n    this._block.writeUInt32BE(highBits, this._blockSize - 8)\n    this._block.writeUInt32BE(lowBits, this._blockSize - 4)\n  }\n\n  this._update(this._block)\n  var hash = this._hash()\n\n  return enc ? hash.toString(enc) : hash\n}\n\nHash.prototype._update = function () {\n  throw new Error('_update must be implemented by subclass')\n}\n\nmodule.exports = Hash\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/sha.js/hash.js?");

/***/ }),

/***/ "./node_modules/sha.js/index.js":
/*!**************************************!*\
  !*** ./node_modules/sha.js/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var exports = module.exports = function SHA (algorithm) {\n  algorithm = algorithm.toLowerCase()\n\n  var Algorithm = exports[algorithm]\n  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')\n\n  return new Algorithm()\n}\n\nexports.sha = __webpack_require__(/*! ./sha */ \"./node_modules/sha.js/sha.js\")\nexports.sha1 = __webpack_require__(/*! ./sha1 */ \"./node_modules/sha.js/sha1.js\")\nexports.sha224 = __webpack_require__(/*! ./sha224 */ \"./node_modules/sha.js/sha224.js\")\nexports.sha256 = __webpack_require__(/*! ./sha256 */ \"./node_modules/sha.js/sha256.js\")\nexports.sha384 = __webpack_require__(/*! ./sha384 */ \"./node_modules/sha.js/sha384.js\")\nexports.sha512 = __webpack_require__(/*! ./sha512 */ \"./node_modules/sha.js/sha512.js\")\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/sha.js/index.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha.js":
/*!************************************!*\
  !*** ./node_modules/sha.js/sha.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined\n * in FIPS PUB 180-1\n * This source code is derived from sha1.js of the same repository.\n * The difference between SHA-0 and SHA-1 is just a bitwise rotate left\n * operation was added.\n */\n\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\n\nvar K = [\n  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0\n]\n\nvar W = new Array(80)\n\nfunction Sha () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha, Hash)\n\nSha.prototype.init = function () {\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n  this._e = 0xc3d2e1f0\n\n  return this\n}\n\nfunction rotl5 (num) {\n  return (num << 5) | (num >>> 27)\n}\n\nfunction rotl30 (num) {\n  return (num << 30) | (num >>> 2)\n}\n\nfunction ft (s, b, c, d) {\n  if (s === 0) return (b & c) | ((~b) & d)\n  if (s === 2) return (b & c) | (b & d) | (c & d)\n  return b ^ c ^ d\n}\n\nSha.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\n  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]\n\n  for (var j = 0; j < 80; ++j) {\n    var s = ~~(j / 20)\n    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0\n\n    e = d\n    d = c\n    c = rotl30(b)\n    b = a\n    a = t\n  }\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n}\n\nSha.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(20)\n\n  H.writeInt32BE(this._a | 0, 0)\n  H.writeInt32BE(this._b | 0, 4)\n  H.writeInt32BE(this._c | 0, 8)\n  H.writeInt32BE(this._d | 0, 12)\n  H.writeInt32BE(this._e | 0, 16)\n\n  return H\n}\n\nmodule.exports = Sha\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/sha.js/sha.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha1.js":
/*!*************************************!*\
  !*** ./node_modules/sha.js/sha1.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\n\nvar K = [\n  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0\n]\n\nvar W = new Array(80)\n\nfunction Sha1 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha1, Hash)\n\nSha1.prototype.init = function () {\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n  this._e = 0xc3d2e1f0\n\n  return this\n}\n\nfunction rotl1 (num) {\n  return (num << 1) | (num >>> 31)\n}\n\nfunction rotl5 (num) {\n  return (num << 5) | (num >>> 27)\n}\n\nfunction rotl30 (num) {\n  return (num << 30) | (num >>> 2)\n}\n\nfunction ft (s, b, c, d) {\n  if (s === 0) return (b & c) | ((~b) & d)\n  if (s === 2) return (b & c) | (b & d) | (c & d)\n  return b ^ c ^ d\n}\n\nSha1.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\n  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])\n\n  for (var j = 0; j < 80; ++j) {\n    var s = ~~(j / 20)\n    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0\n\n    e = d\n    d = c\n    c = rotl30(b)\n    b = a\n    a = t\n  }\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n}\n\nSha1.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(20)\n\n  H.writeInt32BE(this._a | 0, 0)\n  H.writeInt32BE(this._b | 0, 4)\n  H.writeInt32BE(this._c | 0, 8)\n  H.writeInt32BE(this._d | 0, 12)\n  H.writeInt32BE(this._e | 0, 16)\n\n  return H\n}\n\nmodule.exports = Sha1\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/sha.js/sha1.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha224.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha224.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Sha256 = __webpack_require__(/*! ./sha256 */ \"./node_modules/sha.js/sha256.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\n\nvar W = new Array(64)\n\nfunction Sha224 () {\n  this.init()\n\n  this._w = W // new Array(64)\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha224, Sha256)\n\nSha224.prototype.init = function () {\n  this._a = 0xc1059ed8\n  this._b = 0x367cd507\n  this._c = 0x3070dd17\n  this._d = 0xf70e5939\n  this._e = 0xffc00b31\n  this._f = 0x68581511\n  this._g = 0x64f98fa7\n  this._h = 0xbefa4fa4\n\n  return this\n}\n\nSha224.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(28)\n\n  H.writeInt32BE(this._a, 0)\n  H.writeInt32BE(this._b, 4)\n  H.writeInt32BE(this._c, 8)\n  H.writeInt32BE(this._d, 12)\n  H.writeInt32BE(this._e, 16)\n  H.writeInt32BE(this._f, 20)\n  H.writeInt32BE(this._g, 24)\n\n  return H\n}\n\nmodule.exports = Sha224\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/sha.js/sha224.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha256.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha256.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n * in FIPS 180-2\n * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n *\n */\n\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\n\nvar K = [\n  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\n  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\n  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\n  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\n  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\n  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\n  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\n  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\n  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\n  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\n  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n]\n\nvar W = new Array(64)\n\nfunction Sha256 () {\n  this.init()\n\n  this._w = W // new Array(64)\n\n  Hash.call(this, 64, 56)\n}\n\ninherits(Sha256, Hash)\n\nSha256.prototype.init = function () {\n  this._a = 0x6a09e667\n  this._b = 0xbb67ae85\n  this._c = 0x3c6ef372\n  this._d = 0xa54ff53a\n  this._e = 0x510e527f\n  this._f = 0x9b05688c\n  this._g = 0x1f83d9ab\n  this._h = 0x5be0cd19\n\n  return this\n}\n\nfunction ch (x, y, z) {\n  return z ^ (x & (y ^ z))\n}\n\nfunction maj (x, y, z) {\n  return (x & y) | (z & (x | y))\n}\n\nfunction sigma0 (x) {\n  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)\n}\n\nfunction sigma1 (x) {\n  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)\n}\n\nfunction gamma0 (x) {\n  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)\n}\n\nfunction gamma1 (x) {\n  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)\n}\n\nSha256.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n  var f = this._f | 0\n  var g = this._g | 0\n  var h = this._h | 0\n\n  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)\n  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0\n\n  for (var j = 0; j < 64; ++j) {\n    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0\n    var T2 = (sigma0(a) + maj(a, b, c)) | 0\n\n    h = g\n    g = f\n    f = e\n    e = (d + T1) | 0\n    d = c\n    c = b\n    b = a\n    a = (T1 + T2) | 0\n  }\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n  this._f = (f + this._f) | 0\n  this._g = (g + this._g) | 0\n  this._h = (h + this._h) | 0\n}\n\nSha256.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(32)\n\n  H.writeInt32BE(this._a, 0)\n  H.writeInt32BE(this._b, 4)\n  H.writeInt32BE(this._c, 8)\n  H.writeInt32BE(this._d, 12)\n  H.writeInt32BE(this._e, 16)\n  H.writeInt32BE(this._f, 20)\n  H.writeInt32BE(this._g, 24)\n  H.writeInt32BE(this._h, 28)\n\n  return H\n}\n\nmodule.exports = Sha256\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/sha.js/sha256.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha384.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha384.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar SHA512 = __webpack_require__(/*! ./sha512 */ \"./node_modules/sha.js/sha512.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\n\nvar W = new Array(160)\n\nfunction Sha384 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 128, 112)\n}\n\ninherits(Sha384, SHA512)\n\nSha384.prototype.init = function () {\n  this._ah = 0xcbbb9d5d\n  this._bh = 0x629a292a\n  this._ch = 0x9159015a\n  this._dh = 0x152fecd8\n  this._eh = 0x67332667\n  this._fh = 0x8eb44a87\n  this._gh = 0xdb0c2e0d\n  this._hh = 0x47b5481d\n\n  this._al = 0xc1059ed8\n  this._bl = 0x367cd507\n  this._cl = 0x3070dd17\n  this._dl = 0xf70e5939\n  this._el = 0xffc00b31\n  this._fl = 0x68581511\n  this._gl = 0x64f98fa7\n  this._hl = 0xbefa4fa4\n\n  return this\n}\n\nSha384.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(48)\n\n  function writeInt64BE (h, l, offset) {\n    H.writeInt32BE(h, offset)\n    H.writeInt32BE(l, offset + 4)\n  }\n\n  writeInt64BE(this._ah, this._al, 0)\n  writeInt64BE(this._bh, this._bl, 8)\n  writeInt64BE(this._ch, this._cl, 16)\n  writeInt64BE(this._dh, this._dl, 24)\n  writeInt64BE(this._eh, this._el, 32)\n  writeInt64BE(this._fh, this._fl, 40)\n\n  return H\n}\n\nmodule.exports = Sha384\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/sha.js/sha384.js?");

/***/ }),

/***/ "./node_modules/sha.js/sha512.js":
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha512.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar Hash = __webpack_require__(/*! ./hash */ \"./node_modules/sha.js/hash.js\")\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\n\nvar K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n]\n\nvar W = new Array(160)\n\nfunction Sha512 () {\n  this.init()\n  this._w = W\n\n  Hash.call(this, 128, 112)\n}\n\ninherits(Sha512, Hash)\n\nSha512.prototype.init = function () {\n  this._ah = 0x6a09e667\n  this._bh = 0xbb67ae85\n  this._ch = 0x3c6ef372\n  this._dh = 0xa54ff53a\n  this._eh = 0x510e527f\n  this._fh = 0x9b05688c\n  this._gh = 0x1f83d9ab\n  this._hh = 0x5be0cd19\n\n  this._al = 0xf3bcc908\n  this._bl = 0x84caa73b\n  this._cl = 0xfe94f82b\n  this._dl = 0x5f1d36f1\n  this._el = 0xade682d1\n  this._fl = 0x2b3e6c1f\n  this._gl = 0xfb41bd6b\n  this._hl = 0x137e2179\n\n  return this\n}\n\nfunction Ch (x, y, z) {\n  return z ^ (x & (y ^ z))\n}\n\nfunction maj (x, y, z) {\n  return (x & y) | (z & (x | y))\n}\n\nfunction sigma0 (x, xl) {\n  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)\n}\n\nfunction sigma1 (x, xl) {\n  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)\n}\n\nfunction Gamma0 (x, xl) {\n  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)\n}\n\nfunction Gamma0l (x, xl) {\n  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)\n}\n\nfunction Gamma1 (x, xl) {\n  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)\n}\n\nfunction Gamma1l (x, xl) {\n  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)\n}\n\nfunction getCarry (a, b) {\n  return (a >>> 0) < (b >>> 0) ? 1 : 0\n}\n\nSha512.prototype._update = function (M) {\n  var W = this._w\n\n  var ah = this._ah | 0\n  var bh = this._bh | 0\n  var ch = this._ch | 0\n  var dh = this._dh | 0\n  var eh = this._eh | 0\n  var fh = this._fh | 0\n  var gh = this._gh | 0\n  var hh = this._hh | 0\n\n  var al = this._al | 0\n  var bl = this._bl | 0\n  var cl = this._cl | 0\n  var dl = this._dl | 0\n  var el = this._el | 0\n  var fl = this._fl | 0\n  var gl = this._gl | 0\n  var hl = this._hl | 0\n\n  for (var i = 0; i < 32; i += 2) {\n    W[i] = M.readInt32BE(i * 4)\n    W[i + 1] = M.readInt32BE(i * 4 + 4)\n  }\n  for (; i < 160; i += 2) {\n    var xh = W[i - 15 * 2]\n    var xl = W[i - 15 * 2 + 1]\n    var gamma0 = Gamma0(xh, xl)\n    var gamma0l = Gamma0l(xl, xh)\n\n    xh = W[i - 2 * 2]\n    xl = W[i - 2 * 2 + 1]\n    var gamma1 = Gamma1(xh, xl)\n    var gamma1l = Gamma1l(xl, xh)\n\n    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n    var Wi7h = W[i - 7 * 2]\n    var Wi7l = W[i - 7 * 2 + 1]\n\n    var Wi16h = W[i - 16 * 2]\n    var Wi16l = W[i - 16 * 2 + 1]\n\n    var Wil = (gamma0l + Wi7l) | 0\n    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0\n    Wil = (Wil + gamma1l) | 0\n    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0\n    Wil = (Wil + Wi16l) | 0\n    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0\n\n    W[i] = Wih\n    W[i + 1] = Wil\n  }\n\n  for (var j = 0; j < 160; j += 2) {\n    Wih = W[j]\n    Wil = W[j + 1]\n\n    var majh = maj(ah, bh, ch)\n    var majl = maj(al, bl, cl)\n\n    var sigma0h = sigma0(ah, al)\n    var sigma0l = sigma0(al, ah)\n    var sigma1h = sigma1(eh, el)\n    var sigma1l = sigma1(el, eh)\n\n    // t1 = h + sigma1 + ch + K[j] + W[j]\n    var Kih = K[j]\n    var Kil = K[j + 1]\n\n    var chh = Ch(eh, fh, gh)\n    var chl = Ch(el, fl, gl)\n\n    var t1l = (hl + sigma1l) | 0\n    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0\n    t1l = (t1l + chl) | 0\n    t1h = (t1h + chh + getCarry(t1l, chl)) | 0\n    t1l = (t1l + Kil) | 0\n    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0\n    t1l = (t1l + Wil) | 0\n    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0\n\n    // t2 = sigma0 + maj\n    var t2l = (sigma0l + majl) | 0\n    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0\n\n    hh = gh\n    hl = gl\n    gh = fh\n    gl = fl\n    fh = eh\n    fl = el\n    el = (dl + t1l) | 0\n    eh = (dh + t1h + getCarry(el, dl)) | 0\n    dh = ch\n    dl = cl\n    ch = bh\n    cl = bl\n    bh = ah\n    bl = al\n    al = (t1l + t2l) | 0\n    ah = (t1h + t2h + getCarry(al, t1l)) | 0\n  }\n\n  this._al = (this._al + al) | 0\n  this._bl = (this._bl + bl) | 0\n  this._cl = (this._cl + cl) | 0\n  this._dl = (this._dl + dl) | 0\n  this._el = (this._el + el) | 0\n  this._fl = (this._fl + fl) | 0\n  this._gl = (this._gl + gl) | 0\n  this._hl = (this._hl + hl) | 0\n\n  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0\n  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0\n  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0\n  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0\n  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0\n  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0\n  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0\n  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0\n}\n\nSha512.prototype._hash = function () {\n  var H = Buffer.allocUnsafe(64)\n\n  function writeInt64BE (h, l, offset) {\n    H.writeInt32BE(h, offset)\n    H.writeInt32BE(l, offset + 4)\n  }\n\n  writeInt64BE(this._ah, this._al, 0)\n  writeInt64BE(this._bh, this._bl, 8)\n  writeInt64BE(this._ch, this._cl, 16)\n  writeInt64BE(this._dh, this._dl, 24)\n  writeInt64BE(this._eh, this._el, 32)\n  writeInt64BE(this._fh, this._fl, 40)\n  writeInt64BE(this._gh, this._gl, 48)\n  writeInt64BE(this._hh, this._hl, 56)\n\n  return H\n}\n\nmodule.exports = Sha512\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/sha.js/sha512.js?");

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer);\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!__webpack_require__.g.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = __webpack_require__.g.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/util-deprecate/browser.js?");

/***/ }),

/***/ "./node_modules/yallist/iterator.js":
/*!******************************************!*\
  !*** ./node_modules/yallist/iterator.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/yallist/iterator.js?");

/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  __webpack_require__(/*! ./iterator.js */ \"./node_modules/yallist/iterator.js\")(Yallist)\n} catch (er) {}\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./node_modules/yallist/yallist.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ledger_liquid_lib_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ledger-liquid-lib-web */ \"./node_modules/ledger-liquid-lib-web/index.js\");\n/* harmony import */ var ledger_liquid_lib_web__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ledger_liquid_lib_web__WEBPACK_IMPORTED_MODULE_0__);\n// import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n\n\nconst initial =\n  \"<h1>Connect your Ledger and open Liquid Headless app.<br>Double Click anywhere to start...</h1>\";\n\nconst $main = document.getElementById(\"main\");\n$main.innerHTML = initial;\n\nlet isDumpSignature = false;\nlet lastState = '';\nlet pastAccessTime = 0;\nconst dumpSignatureProgress = function(lib, textBlock) {\n  const result = lib.getSignatureState();\n  const cur = new Date();\n  const hour = (cur.getHours() > 9) ? cur.getHours() : ('0' + cur.getHours());\n  const min = (cur.getMinutes() > 9) ? cur.getMinutes() : ('0' + cur.getMinutes());\n  const sec = (cur.getSeconds() > 9) ? cur.getSeconds() : ('0' + cur.getSeconds());\n  const msec = (cur.getMilliseconds() > 99) ? cur.getMilliseconds() :\n      (cur.getMilliseconds() > 9) ? ('0' + cur.getMilliseconds()) :\n          ('00' + cur.getMilliseconds());\n  const timeStr = `[${hour}:${min}:${sec}.${msec}]`;\n  if (result.success) {\n    let prog = {current: 0, total: 0};\n    switch (result.currentState) {\n      case ledger_liquid_lib_web__WEBPACK_IMPORTED_MODULE_0__.GetSignatureState.AnalyzeUtxo:\n        prog = result.analyzeUtxo;\n        break;\n      case ledger_liquid_lib_web__WEBPACK_IMPORTED_MODULE_0__.GetSignatureState.InputTx:\n        prog = result.inputTx;\n        break;\n      case ledger_liquid_lib_web__WEBPACK_IMPORTED_MODULE_0__.GetSignatureState.GetSignature:\n        prog = result.getSignature;\n        break;\n      default:\n        break;\n    }\n    if (result.errorMessage === 'not execute.') {\n      if (lastState !== result.errorMessage) {\n        console.log(`${timeStr} getSignatureState:`, result);\n        lastState = result.errorMessage;\n      }\n    } else {\n      const state = `${result.currentState}: ${prog.current}/${prog.total}`;\n      if (lastState !== state) {\n        console.log(`${timeStr} getSignatureState(${state})`);\n      } else if (pastAccessTime !== result.lastAccessTime) {\n        console.log(`${timeStr} getSignatureState(${state}): time[${result.lastAccessTime}]`);\n      }\n      lastState = state;\n      pastAccessTime = result.lastAccessTime;\n      textBlock.textContent = state;\n    }\n  } else if (!isDumpSignature) {\n    console.log(`${timeStr} getSignatureState:`, result);\n  } else if (lastState !== result.errorMessage) {\n    console.log(`${timeStr} getSignatureState:`, result);\n    lastState = result.errorMessage;\n  }\n  if (isDumpSignature) {\n    setTimeout(async () => {\n      await dumpSignatureProgress(lib, textBlock);\n    }, 500);\n  }\n}\n\nconst proposalTx = '02000000010354cc5be98996fa6e7128922c65425652746d2b9fc57576e9c54cf73f9e245bb60400008000ffffffffacc35ae4c07c0d73110c97f4b6d7fef5464f3c98dd60b8b2f655c2e867fd60f1b1a2d523532697e23070d333db069339b3ae94a15a075ac7f8e4f25ce86d7892081a68eb432a7fb0f286bee1c2348fa2d84353b2d3b8350c1f518958a87e21ebd30054cc5be98996fa6e7128922c65425652746d2b9fc57576e9c54cf73f9e245bb60000000000ffffffff54cc5be98996fa6e7128922c65425652746d2b9fc57576e9c54cf73f9e245bb60100000000ffffffff050ad6f88035d77c23ae409242de725e8e10a889dac1c2b2a9b06354ae426e31d0b608fe2e688f7c5005d64cbb0639f9eefc79ad7749a243317c8b9db747bb94f50ec002862fe34b4b6607bfa362065965ff0e8da5936f5a4c640c49d0578a879746486117a9145147295169feb02e6de34f2443210318de96d146870b80b107e44529efaadec58dae4af49821bf943a1ff8eb6f9936ecd3fa6c8e93b0092f260068d35adb85e242270ef89d4921bcb09aede102d4a4da3cd4cc63c4e7dc03529f1d5af508318baea0c72cad85a78bd4f5c94f9be480de99e4942779a95ef617a914c89964d7512214d8cd4cd8a2c2c57e7f4238ce3e870ab06a2ef6f83003ceca11d177d1fcf6cedf57a166ff4da71bd97e6b10768e8b9908d415daecdfba9228eee863ad881b3448760d9e55d1475aae0e6517675362e86603af1b03fd752bbc05aa60fea1a235b368e5ffc9948955e23cb72f8f76a79e778a17a914cb25143d64243ea88502dbf8d761b7765d19f977870125b251070e29ca19043cf33ccd7324e2ddab03ecc4ae0b5e77c4fc0e5cf6c95a01000000000000c35000000b3aaa8332392f4bfad1ffbfc1c00ef77999892efb089376c9bf31e3d444ef6fab09c125644453422d3411630a44405e0c67f1ef441dc284386cbea79bb91229686a0385f7b6c6de2bdaa307aae7a0085f80503b70d2cc01828910fa5cf359aaef6a5517a914f6d243bb579d8823d945b8415bf59c76400fd3658700000000fd4610403328cebf01bac61c8768beaf125ce55137cad91e320c58e3adaa284e4bba381c2934a428d517a99af681936c3634160b53b2b8b032fc102279fe9eccbe47c46c936424b89f0d2bcb096383620a254cf616d4d72679c1753b75b32bd35618a81c8c614dfe5977e511eb67bcd28f5c8bb651362ff982008705e90e191364d73d87b1da1a0cef4644a14c05001f8eb87a4f983a87a50777e0e4f11326dd1d49b8a8bb9042275dda9909a5c20ae37e2f70c5d6fbc1bf8f298212bef5ebd642708736c09a767f48e704ade2820e958b0b96af2390327c95db25f8e53f77e2260eec551e3865fba51e06259fdb2ec9ebe9dd60c982181f0670a073ade76ae86ba5750b0696ba61a0d06559c4fdc7f2270d7dfe7daeab07426175536ed64bfd9550289f7445aa2390ee58e9f0867201aca40c9d3f5b92a90eb5db4587b0c71e864e9392268a001e5bb18cb307c3c7b94e5ff15fe094fd112581472b7211ab979528242bc893975d86179a4954970a16f954baff0ef63970a0e1896348ce758de3c62e86811929f4fed2ba10df7b7769aecd45edfcbe50f57456e0da356672ca8f8b3580730261fc2c14123552c85714eaf12a3c93246de3c6eaa8214210759679f60322c24d94ff59667500be2abba8ba45038e0b32c231e00ad59116895d22a5a25fee2adf2bd48139ad5daddf032315a3e3d10515bb5bf6dc05bbaf9b08b1250423725cc7dd462b9d66bcc8496f9aad8b4c0a5565cb670963d716afafbe37f06b6be4d3d3569e206642f92a9e448f2087b82771a9920076a194363fc198456d7f073cb692d122f034d50c945064f20bca6f606c61a951638a2721471014edfa0c70d8b6ae23c13a7a5748c87bb75cb55344b6e0b06760b9e7843b055dafcfacade24dcdc62126a66082189d2a81f5449a33cd4c1fd621f3048aed28992a6dcc00a54e4f36c9cc0bf9575b1d2abf3e3a3c6ef970bdf634be39d2d765caaf9cccfb8827d26ae79a9a360f2cc3dfd020acc331b23dda5688dd60b69fecbccfd8d75835ad3aa8e66ee7015edf28bb57088549271f26ef24d4991e7ba3873590252bf23d1bd5315f23038d327ac0069697b91153f2225c60a6ed6b76b5e1956ba7450cece29dadc6329036f2ade41b5753b5afe0c967818d4a9f1c7c10a88e289db1996221e932e2e72a59fe4b5ec7f2af0d67887fb0a836508628e50ea7309bc13809141d59de26998836952cd5fb233a23f02abfa834bba926604b836707bd194e0aa76ae391c0ec8d1656b042e713e2b3b8584711ad219f3a682139a79c9d5cec32883972157c8e57748d367f4494ccc62871f39b5cb080a994e7b624f7b494e0e46c9b52ef39603a6fffd74129270e67eab6afa526df91cb5b6b8fdcbadd462923414ca003ab5b84b9d0633bd52c0cc7cf5cebede422ab481d85de75028b0873893cb747831e02f7c8e14e46dd3d49fff0a83f5dd16b254c5b68a01944538afab4fec21641963c350f79336be57ffa67664164e97b0f86849115f022820fe5e7f94911cd76596ed9d80cca25f30ca0ffc270d346be2d72521837b2cf5681244c5e0ac9d4165e50600f09d9ee066f40b1a25fdd93bfa2c62753903af5fbc240cee0f40eb84a8d583a46d4aa455e175d1450f082051ea3bd725c3ca8dd53c071e58c1f0ea3c29dc77a4ac3cb7b9116354a2e3c042e2968de826b757b132b5c84fd6e6bd2a4102927c7899301d1ed58a6f23517feb2fa4aaf5799cab3d61e6d3c36507b978771525e7ce8df4906ee47e1a70ac8dd5c076d9bf0a8c7b28ec6baf57048c8cb0bf8b98b531c6d39d66f324bb0a4817e684ef637b7f2458768ebcc5db012573ce3ec1beb49a9047d22cbe4749fd01fe0e9225b90d8bce7be09c12aa6f11addb67922ff51a72572dd90e739048a836bce388d397c5ca8ee00f4ae3a656211b183273c0356e05b5f30f241326d96044a8d2d9c413c75bdfb346d8e677930fa1ca90e966afa0f62d0a223e93b129ecf03a169cc2427ef22e96393b98c5eba39b7d7ca2d0cbe99599ee1c2ed5256b6e50d7eba8051f3622b837e55ef1c107ec0d610ff9498f73e93815226a6f4ac29c55f4bee906942b25797654d9144223f3da6cb04b96a2e67261c8d15e8a4990fc68026e35dc5205f474c15494c84ec59f4ebe5d11c11617410a65e84fdc0334c8eb36ced05e80e5992da59fea5cd860fc7a9c156eb5e6d1fc407e12d71566a13dcc53c8511bc2cdc61e4ff150fff6844a211df62f19fe67478c67175ea2ae49f7add986474ca67de9e46f8d75ca8f9146a17be7e2e40b9f73f524d7e811c01e158185b8ee380fc41270132b83276087edf5518479685fe89fa3e91bee4808ec4ff3a342fb7ceeb9628594fd610a26d8bd04ffd4fc06d89fbd3aad7b52c648cd02061d201f4ecf7717a68cad28a71da817e2b2b2d4a831d2a58ff9ecf0289fbcd0414a7fe4b4d1b11572731f22e2a4948b46b664a9d86fb1192d8267e48371df699701d061d463a2b73de36ae6b3f887fca698c3c067658980dd252ff4733be9e5aea5b7fb06dadb928b0fd9ffb8de58fb8dc8fba638e2193c0fcc58aa1a3d4d5c85bdcc0257596255034fa6fa1a6ed88e9dda75bff3935bd6e7aa11b32e7a6bb8ce728d577dbec61683ff5c5df7fea38275cd0b605263d493c3d1aa9f23882d46107d6439d654696a97521d7dc874ae717d956b50867f725eedec982184531e8596038fe9441ebbd5d3947465c8baa5b1bd9c1db6ab74d39e93f41317b0a4b7cdec46ca992f5a9bb4f26aa4c6034e4d729f8d65cd6d4357a35ee6fd18fd75c58d5a76787452caba2fc593792642cf5c589bcfadf80aebc44423146e3924065ed88a9966005628e24f5d55aa0e78b118674e24274789e30f90103c234d6c810d62be56f151ff1e5809b4f9e1ecdac13399dbd4cce1bcb9e8dfd5a2fe79ff7720ed03b21b6e54b26667543033a796b274a0a54e0b6af5e3b4a30e336d11bbb670df998cac780123788c73380c1c37806be2f9daf7dcac75a35449648490b14a06510a0d8c484424240edae720e2e19695f7357e2e079384caf3a2fdae0cfdc27eeb075d2d8e11d8fe7c0cc441aa6408fd00d9447ac17e0f2dff6491d3787e8b3f4d672fcb8886b4a8c34495767e422cc5988c07395ff472cb7f757e52138d75995c939411dd57c78b40193d03a3a15ac61b6b851e955efb34f1f0116b49ca010032ece14c3f0cc51e84d12ef854214c8a5ce26a8d939df17f7c6aac15f8268e0b700a11e16a4853fc8ad0298d1d3a3acae4195cc96c5f7298c0aca0b506ebd0c9f52b4aa557a55872371e782d1d45ca3acc3fceb5f7272da6fe4d76c9e93b98b60a12f88dda43c9055cf61132feaf91206f9da3c38bd6fa55ab26f146cac8e9eff84933aa897ed3797067af7470d2473e1fc15a0bdf816572900de1674e42b5f41fc968dd921b54b9b18adb1200c595040b05386d487df7b8fbe4646507dd7120bdf4083fc2e78c79f2f101697e2f8968ae454d07cdb7e496f7fb0e7a210ae20c004c500421200dde1f6b759907552b5d1b5d9375d9fb6f4e84a1ea834bcf4337d4d693520ed7a6eddac5bf0ca9f87bd1a7731be1bb28ec8283fdb26ba56e223c9c6dd904f3ea9c68d05e2a9d94abdbcbd11d95565272aa694c24350cdb1a261cd31519325a1601d2c0d716a2060cdb4d85ba69e2eb907e876b078c01dc1067256d02282eb1bc6d284093284cd50a8a7afef595106d0f9b91a1a0f86909fa4396f8b5b0591894ebc00b77396d78a1ad3d7971050427854a21d3a5e0c3afec2df83c46715538d6c5b157edbeb8863ca5e0249debb9437edc7a03a02d2b4db883dad9e1d3c2927b32500f70e6a7e81276e84a5ee72a4b174bcb74b30598bf0bd35a6d358b665ea3a6ad066e57f5bd733157e48d0677f2edeabce643fb87c7ce076bdac6af192b8c570ba1bea972fd032533bb3e908d9d910daa4f1c8d56d5809472bdc536b16d25f0240dfa1193ea333f4b911cc2287144e3cb84559d215686c032342f0b0ea7502fe80c13777aebc3cb0ca7f0883dc002749cfa196e52c339db4156ba81bdb507c000c4761cbc48ab725e7889ea64b3c53b7c5f4fe14bbf4219cf5f605299a606090bb1f2480131a85944ff8a19366ac81956db2f64d30fa8a373fb5428fb1dada3f4f33f1f266e76e56ccc49f56aac801b1499f0c5ae1141e8837e277f1c3954c244756798d1f3f5ac6b3984d7715a863df3079b90604f30aee0d25dd8f5f3492ff5cfacab3d1a56c4e6b12e9aaa51d878cf1b17308321508702c44c2f875efcb1c9720f106555d032ef715daa5bc0a940642566c6f1403eda4531cdb64ee9602d4b94ce05d22bbb63b1e49cbf25ba3b7819f0b89c61b7119bd54dec6a39dc418e69d82b31af65d0cd047b6a44092ffe2777d11b4a489ae3147493903810ff9a4f676db3861adb280a215187fdc9dd4ad7391cd84cd30608259e396e7e105691168e8c9ecfde00809d4048141362e39da874ac3c6dace9cc09e3b8a4a73da47017599df0c11cf0563980df259d04a1a6a68df0278074da62239bddf0327f93233e12971d56755e23be57c893e9ec293b402c86331c267484ac63dff794e83c9d69fd0e06f78bfc72948684925ea336236e99716c6749516003ed4976f84806e7c8006d67ce21a4e8ce8a0b6d204ebdb5cba72747cd4c3d6d42df958093385686e1b5feabdbc5d468f55daaa16c78e2720d5616b8af22f786b1612b43af8ded063601b60662bd3430bc7c8396dee51a7b1d5839c2a231100c123f595810829472f476b1174350ba13fcc0a45efd926e2bf5ee8b9f50f597d9c7b6c3fccd7098f33c418087a1b3a3a61a5cceb8d8cdcdf4f9d02cd2f7660972b0440ea04a4038e7d15fbb49a41d79e580de6173b8860d1a37c60e4c22a3a7f1b1c013aa5b4401abd3d8415c15bc59467ddb6fc6fd86d5743b266a06a91e8f7e59f6c68a8454c8931d34d0c42ff2698f3ada93a352b97f143ffaa19ed07ea2af5ef972c62279c57a2b63e87aa5934e23d6b6deb1191fd2a78aa22d6e3fb678da07b83d70b687a5eb7cb02013b658e4b69209890a44c45635e7020030a7dc080a30bfc277971279c438fc4f2b1634077eb2993b5a337ffc5619d401b553acc261db7b0368e8804cad7a46c9aa86f233dd2e4d6e9a7df1a9a76b01f27577ddff2cede7e16d292967bc5c9853885a05bfb7f80368cfdeec50c32fd33da57077fd12a813f8756a1b2b1bc2c5fbc21b61aa7d5685caef35d9259ea06973f429748f08578d09984c3693bdf205720c3d363fb05b755d58640d6cfc0008eb0928bce598e5918fd28294881819b53b6ff12af7a47f9f39df8d3b15c3a54088c2eb92720a698a08679b50ac062b1710c062f6c501d9a864f50b96b796c1ddb008ce15f09f7a74d0dfaa2fa3bf95e4acd8dc4bb488055f4bc12f9589c273f6057277f7fee43d3f10435e13e229b4cdd684d970f626739ca038aa7a74e69e768569d252a10db5896881c54a4678c78ab6c788277b5d1f6cdab11d8ed0250eb0620c415a53ede8e414267acd931b6774822daa156f210aa701c9c4dde9739f8479b84af44f471a934bb44d9eb071f6ae1deb377e5cb9ed28f326dd41bda9b3dae7b3e3e65f85a3a2ceb0324aa86606a268b124eb1b9dd5869a5eac7b142d6162a30c2653f87484b68449ba34cfd2d35d37996eed3d65bbbff5485b56cee74b05c2771b7e6b312ecf6c83568c20cf30fe1d0a718ba330f9a2de8160161f7ae97ae100e2a4710e4ffb7f702d12bfab852ef68f60bcea8f7da6abf27912b835e89dccb95a8f383fa0fe47899b110f36f2180c606f5eaa3df7b371da253d11a98f6fb00000000000000000000008304000733e12ac9c2761e92aaf8cd0818e871e4bac86546ee92102f927f30f5cb73d4d808dcc021963d841a601fe61a71a089e9baba699a6274cda2d5fd7f1a00010528a16ada0969a4df5016aff8832b1b678386f51ed3e4757caf8d0f233e4dcbe89b9ab8dcdb9188742c7a6a141c4282f1e0894012cad5c11f75aac073a314e17cc3fd4e1060330000000000000001696aa60122ff3bac63b6d0c00308ac85fd43c76039537b1c3e41f21964b46a917168261222883fd7f26642479921bdc40a27ae183380da7172035ec2a06f76275bed497318a0ba3865ddb02ac5cfe89d5e72ffe026aad9ff5b15a4bf95eb885504f3d28c48da2434bf4f506ac4e31f90599f873c66611dbee72dc0d210734894006519c7eb45a57cb7ca1d68520fb653396d885bb77957cb40170a030c21a03dc37d8cf9796c3f47384a31a911a2f2be347829188695c05e641ffbe89608865b0e239b480680d8ef6579baaa7c948ca338045982e695c0a2b95d574fce5d99f5309a39827373d0b43e2e51b5750a1b84a2f9576589fa0b56bcbd62088a99efb76f3a4d02d904dddf527c284fd1ca309ea9438cb3f38e3e1641771dbd086416012463b09f9cee9f2fd4af6c28bcdfed6be43ec197a89d22057b6efef44920bddb3d5052c4ca1e1687d3a9100a26a23583a4306adb9a0514373f138aec06e423695848ee88b31cd9a9c6257124e974914760146bae941d816dfc4128dfd6f600cdfd7e34e1417068e7a52d720147941aa52021fb6c71dfea28086ae9f11bd2c47c4137dac44a9913811320de45388fc8af63612068f9edb3b9207f79034f79a5372cb32c4224029b701230b468902322296562f8b60abf574f4ec11843533d6014f927ec9efc606a6d4e9a9c4e4b5403aa0c5c15c3b0ebfdd1baf59e9143d9ba6c17097fea3f03bb2e377eae45b96d6e0bdfc705e9cbc7dfadf4e53dd5b69b7c04f9022b8fe19b562bed08e59d64500db6606155cf317ef4904778f6e1a5e1a7c3a93e4dd74db5da334c03261247d5ec9b80ed38b67448e3ced60925ee251056b17747b225282784e6dbb716811d08a198fd4aa4f1f1043d4553feea9c58d531eac735c803c0846ef566244ffb35546ef80b185002425dac7c51f17abc8829d498cbedafe67f0e1be2392667bf4cfaa067d925b0633ac995b83f7d5f267ec800dd6cc91e5601dec23a104e4dcbe1b50b8f4024d5e6aed77eaa35a835d8d5758de8d8a819894b26cfd3d01c8dd5499fa40a5561b1c98df51d481965c1d33e9d76d2b8e5c39f8f947ee3e55ba8ad81c4e588af15e497303da5aa7ce73ca75e50541cc1a679dab32ff63345d566015cfae6ef4e6e69d737e3b0ff60d86ac667bff2c14c2bc85e0480f079a82ec463b6c6e5cd8d70e9a7d0dc48b5e02a646762361a8b01381089773f1b926308c9fd297573c6f92f9db23ae426ca48296cf39988cdcacca16d9e3952c88283d7446daf8664aa184b5c5aaa08ff2f9b1277972d4b7585ddb86a20566d37558e5cc561ab2627773ec86dd6e590f73354e031433810d37ffc4b6c644a5cd07eb96e84918009c79bc9597fd7b5a70fdae09066023e622712f78201182b0b312cbd149f1e0cdea866b52e6563a5aa01934a9adde430a05df4dfddfc06d994b11c9be3758c17f397e65c825c38c5bff9453aa29b5533918c2a4fc2364a116b489d89e52aadd338d0871bbd713f42788693c97a1e45a0fa0e0e1365ca9f8ac01822cf581e9b987dbbbd91d77b2cca4c64e32d1c4b8d6a1cda690d07cc8dab5f5cb6920b461509c3166c237eab176f9c922809dddf38714e3ddbf656a0805cee88a03967fea1317a70d391f1414c0bd178b53320b51a602a29909a387894d2809ac76ee77441b04afa16532a85a87cee61abf0b1a74e894ca26e984d09ed2b3d0499a619968b081c392635f553f7e1ef60d217684cc5ecde70a7a3592b18d1a6fd89f2a6d06d788fc200efadff3a27e1d2d589ae78243570ccce495de84cb8baa66c2f93de991bba46e32e4aa9d350d3a5341b2658841f828eebc925ba2a7789f8a7fba61bf47e7a230e2fccbb5ce586dac12a139d8b98dd93c59a0e4dc0463b5c5f066f07ccd04790448986889da78d85d5b3b822e1009708afb9e1cb40979af74c8400ce61dd7099560a35ea09e234f905ddde59aac5c238526e17172cb6b390a7aab9468dec7889d440bdd1005769cfb5557ff25e71dd1a9bff38ea1783cabd13bcabf7a96b7b54914ebd56c4f32afe08a8a9b583a3c90328d666d3d3775a8f90a17c02e197b807aed65b3dc63101758fcaf7fac2797dc18937fa744026b7595b326e6e221530924d785d8115721c7a2c56bb01eaad303a1f6764fc918b4c2bfe2e70a78dfca8194619f8a9e156acfb878783c4f9823dcf14a537e80a1771161cefbbf17c88bf495ab8c0de77817a99375cac265b0468415713acbf83a956e04e694ab56f220da3fa89afb63ba3c5d00b310e4419ed469f945de0f2ce5f04476fd2719cf5483052f73dec3556031f62a79253f5379b20271b42423cf6a59d9a7e86bc99f814306697066fdd47551b75be098de040f89a890a9bf7b302c48b7fb4e76cb42959f37a6fb883ee94dda3fd5c7c689c5d70ac4938f0a1621a1025f43d0418efc452eaf682923ad374a88d68d8bdd1d52a9b61754a35b014ac6dca73541476992a01201ecef86fe449ca9b185b8689a67cecb92c3051e5b0d3565ad52ff9b8bfd6f20404c1af7e8a05b50852e91365167895bd9124af6bd6495b93ec65cc31905db17904620c1c4085baefdb148100143087466d65bf0796d1fc8854cb028c8a7463aa1d87294cb2d6db611789d1c19182e2ef4905e38f0a2414a9a519f05468575d5c515654b14a860ec0f649e3ff2cdcae5b5b51318c1189c7fd887b606c0cf37259d0ebc30c1d5761bf4549e5ef64065404908ecc615cf51e7d9eb42c5b10a6d71675c8f5da6fb1d5a4625c22b55105586606b7d018b8caa90a0716bb0313992e7df9eb68d52e206bca307e34cd3135e3785b6a629e15fb0d8e1f2c913082dbd52b223d487aa2c8f66a33360b7694a5a374d51ab768533a878b39b65ec8b38506b96d53bcfb778ab9489edf2cdb3e2c6f5a3c1e14f6021f80a460ce73b8d70f1c5aec2937529980cb5ed753e9e79d5ca3bdf90b1a9380dd42a9765b6182d5a07f7589dc1041fa4aa37b25240615a73a7fd3c8342990d597e839a8a8f620a55a10a15c4de81f7cb758bfd94eadcaf06b938f92c986908bdd33883a002f2bf7a0e5fd76b596c092c89c070017644b813f854b7fed6ae6c5f6d25ee4643ab8505e2339f096a55836d93703ddc1a5d65c9388153540c51366692dc767b81bbdf0f403cccfbf324622cede2cc62e7b401dafa740a816790a89df5c1b7a1cc5f1f55b1455ab1809ed55ea9337fb9e64630e7bce22eb9b0365770563fcfdf1f84937772eb1e8307850fdfff3765085ce7951b98553081035be2db51353f85af34b82904bb85c1c95baadf2a9f3efb21df9918c9a779b9591d4812e24513813ed382d31f193e8a228999eb23aa6c8760224440633d9dcdc9449d6b83ee31e3a921b2b129abf93ca775064dde53f93cdb50343d239183133ccfa55ca06dfcbd78d2a424bc1154e868668fb8960e4ce9f6657f8f458ab0c3268706f8460f15237554ef028c4c9a616091301694721ea8403c5817e7bc736f1c61cbd2a80d0becc9cefc0244965a7500706b7e05288717823a06b80794bfc95ab5def7bf8a28e634300b6d94461d489be5ce08a63b4067930538653fef07519780051899d8c9d2cb790a1b2378c23c7d153210f57668e8be6e2a410d1a2419694183b71dcc4a803192354d8b20e7263f60c0fd49a1b33c800dc6f2056b447bd99dc43d7b471ef6ab9e5c1bcbb5dbeb01d6ab64a55404f4823b613f648c11056781561a1d90516a234f8df92580d7594e329ed5cb912cdb1cb3a9f65fe17eaf8c4f26321bd8bb14e8a3667ad41e9c2f4b4e440a1ba91027af4dc8565b18c017ee4f10d443120da838e1c5ec72a6175cd057c94af3d94c066c5fccd4a53e1f2801bf655fbbf12842f02f4344bf377b099e841fea8c472f3de25736368a990414180fc2a5febcf002e0073823432a5039be68975a25465f69d9572dabc833c5e5485651839cd7ac71fdb887ddf68e8dba1155ec6687aeb89a5438408c610d7d11a238d7aa55335ea6a018afc7b1f663d7bfd2ad5544ab7d5d5da110b51992441fff5ff41a8477491927c64bd3c80f0c31f06ab566e2804e348c861d6c2685b098e6cc37fcbfedb705f567f4c9e5a9a0626a4dcdcf2589b64edb551a6d589e01d01fc95e06090bc983fe1e2e9bd6dfeb6e487a1a8ea69fc614740e2480c74ebf4fa38e921aa6b2cdc58eccf5352ced192c2bea4fe17562132174bd7795d99b8bde487f7ac37715701b5a09172400bd2e41caa889a1e4d727e6b932b7a5c648546f735893d89ba11244973e32d58c2c8b7e05ce4f4fefd0ee6c8b5657ecaa6e02f1315bd2997259bfa001499d148a3d50c342eebee694ee4ab7ce296bc18c69ce78673e97b40b1b2da5b9ff0ea972368cc84513fd05ea856c8ad85818b7a7a552b86e2cbfacaeb7faf85a10930897f85d7e904ac05f2e8aabf68764f59e83da72688ee845800073eac72712000f66986ea7b4cf548a6b6e22e211e4b7768682345bae63fe857b19bf1b264dcb30e16cdc4d54783036b1e9605e841105f43595416b9f5a422abd45e537f15fbebd3b01bf9c72191bebf760ed252dd4c24daf2eaa02d93a8c3a3033842fabe746926e15856d58f1cab1b83439394eef3e74a18b6088622f41116caf8c3db51b02b5dc50f92915b215ac48529857ccfce468c0d003a12e231afaee79d84b01502f6dbe9dc58942e42c3806ce7b0c4db50cbf07aba375f251a1da3e5eec6b56dd54f919eca921b9b7ae37e2a9a3c41a83d486498e75cd8883cb1c3f698351c524896bd2790cc878be580982cebf92964d023134701f3241b1a169e1dcd4d72cabd46ea868e7ee9510ad9a0b4cc9d71a9f89b4e772489b8a9ca873c475cce30e7720636dd30b51ff852b93c4d0bbece8a994ecec7d601a1d6f71be2631a680f980327606cc85c19891d6fc1a9b1f3bced0b8be18bba62a5d9f936a6fd4db703959f543a1cde8f271ed6ad074d5771090cb2a2222bd107d8890549d33cdcaafe8676897ddab5687c250726690bd121afd41e52191ecadde5a2f263fb8c49144eef3ea044a3910fdd3710ebb777aa6ccd706de7b70e70076ae4d12e3ea0b68b40c77b7a7a0584b3e82f881a3bc3dd37ddd8dccd0ecb0e44ef48aa66d5a50ed95f7b3496ce34bc274a05e3a28df9d27f3b27742c1455ca1fb6704d8912357f0f9471111eb27c20db53e6a504e25d9af757211049ce25ab286e932d468b3f73d238478f8e3bd6cbde9cc3807023b7b83dfc833a761220b689979f6fe77682c6a994cc2d0143e1d07ffbd9426cc1d312a695e2a399621805675f4dcc3ace15e10c0015f3360afb71bb06d37bb2041cfebe116bb838c4dd5ab38824038f39af020046cefca2573cf297708271fc599deb48a53196491278641fb101d955fda6910f31c6873d269daf80e23f61e6a243b120461393d6f70a5be634399700c936adbb3b930077e194c6dfdf4ed6f653bbb64255a8fa47215a798f03f8aae9910423b019038b6b18848fb8f12070c72c081ae290e15c0a12016a4930e0762ae12bfa0f8864f707184b0a51069f0877c2e46636148b32d0edbdfb51e11b6dc770cf3b4d7ee95f780d7220490e3fb5855d42ea0286813a63fe9f97907ba8a73a19a9c8f3dffbf6f1de395361372cdf1b2acb6538054b46c4fbdbd07d92d3a52279b04f359b917b92e40f3c1e3714b43e1109902027235f503eb349b8c23a787f7989a08933fabafd4d870ad61e7da4fe90eaaa944d9f55e52e4184d0e79a271a956ee24aa0797829014256242ef113a9c213aef404e74c30a3997ff7ad6b6583066272844ffe5b422d982f79b4a9828dc5de3c2faff30d813c3fe464767e03f5d68304000e6a09de5ae7dd7c22ef82c7b7c946ae6830d00f8441188f81f9a4000aa290f2af61335768494c43ff4b443c7b32f914c7c5a2fa07cae2967751a59aa21101ad85bd83fae9dd1e45da6cf8ff5d021e6abef0295431dfeaf076e29b7546c8ae7cd225b3b92da38e505341b4737d4f1d9d513e69b61b2e7d2d14889109613a322285fd4e1060330000000000000001f2c748019d4f3c00569754c8f661e935dcc5d35a686187939fcc8e0a744bc91256e9e0f0a167615d1d1cf7a38aec618d5f09f4e0509b7e1963fe98a10ff315612ad60bd333f88436bc8b5f45439515316cd5dcb375277ba790477ddeb7e60844526d2ba83b1ef3e890ba1ab39a42b3bb33daa102d84aaab99fcd9574ea06c6bae2669107e0d526b79550b6f5d17d66cc0151c22c882245102d24ecebeedca2644ad2483d56285dc9bd29fd0caf369bda744edacf0dfb12116aaa21997e62c501d00c9beb26ebe6399719a0a618a02177ddb244171fc7f1d91b9a4ea14016e12a451c722f28d0abd88dbd6b63a05893f6e9417ca3e61751c6142be3d2f80f33bd640be8f8a7df907797e72cf00efd42aff6547fdcdc9141f0141c66fba670476e7cec6ce53bac46f46f978261f627a49dddf50a6c43b91e97536a3862ffd665be35e317b6f204acfdd83a6d01c0297af336b04024dd70536d6a1e9dcc6decb381a9ef91e25f6996e7689f43b3ab81d8ac2f2caa247663d8c58acbd3cc5354534349198b20eeaa38e11deec096b775e3519343a40519de7977288a266e2d478bf44ac0ef686192b6b57705e0aa20e81c7a687d6b4cba32fe4fb998c007c31f5d6b019ed97adef95902d5e402fb561f8a91f8b6a6383dc97d71579e8056e9f7aff8c530ac3bb1a47f4f69bfffa5e3433e6476bd4eca7db58b46d59f70dfc2d9d67f9247dcb1945dc8c29ebf28b5dea8642ff3da9a172513f6f65f9f0076a4fe5340163151896383b304cdd58147b21a4ed9a32bb2bc7793c9ec8353f91d98cd10f308c0e1887df9110473168db556098b39b318480a5ba31da45fcf0bbf8d28084d6fb3b2af1d72e9f134dcd21d343ab5afbd270f1f633230486073de7cf146afa09c51ce0a89dd841f18794d30d8bb50341fd47d73da390d25c4a7736d86cdfa22b3142774289809b32fbcc7955507bb9a340a5b45da00425da23dd8d565cfc7994704290e96a3e82125e195840aefaba3a9f6b7fd744ce5c13406e454e2b4fccdaff427aa06b27c753a076c163efe2a263171b3c5475b7bfaa383c9df080c22478a0d8b2fc4c4a9fc070f032d5dced9f9357d1621f5c5facd64f7ddfeaf5a4424522415f83bc193973848a06ee8339cbbf67c4442f52dab210e9480a8b59b3e69210e4b0d7cc6adbbd2b36e42cdf691ba88e34302e777766700e43abba4a035f8ae40068489ff01734535d57cf9519972db541d2611c20958d79fb55892c25d77b5c4ab6666b3daaf9d8c4ab4cb9fa4b3116d4eb6b22895fc2c512ab32b2800b6e07e05a23491a83367296c26d609b17de2c88abe1affea5dbe523ea9183a09fd6616b0ba8c74052e6be3d7da1f0a61478f9bd3d9c5e660727883150f02f1d002f87540c0448443b80b2df5467bf0208bad2513d56b0cf5489d8c1cc69c59c78ac55f64c5f15fdca0ab41d432341819a6967af62be6dbca689f7beed9b6c339ab435afdbcc22c910b6a07df6f9202fd40d90afbd8070d6dbaab3644699ee32cb224dc21ec84ab9af68e9d9535b6325e8f080e93a0b6fd4128a8107899ffbd6149707d51487a78794c45822ccfbf74ddce6db98482ec339a2ccd8d7375ef41322abc4d7f7f9ed65fe6200f49314402356b4eeff5000497b75ec0e935702a0c79a360b37db1dab933b5154622026c03e19e98e3b853ef0ca1fb910ffeff31635b294b066c1f6cf5378b4d8f6d88f4fea5dd18d4bfb39f6286b4d55b84973ed74cdc3260ce49debff60bc5fc6667aee2850ec60a2af8bb29d02e35241657b592211fd538e59ffddaaccf8ddca9cd579622374cec706aaf9bf45f861e4f62e5bf952c6abebee61ca8c5ce1e0bc667591f32c39df0e6d90b60f57d43b60efd13a16a37b59860067443ac482cb3a57fd7da90e902b7390236f2d7b4dd68844e2c53a2cf94094d925a52b7e3bfecb71fa34a05b7ee60dd43dd2bb922500f7d3c3a32e6fc40160413d63e3ccd1f6ab67aca281d86e8bb75604a3365981a9af20b82797304bdc01084ca4f890fb1190c49ef1871f32e86c54f0c7ec54b49178cac5b43bff7053bc373b4a5e235037b57547141f4eb88e227a0401c44e4cd56e95b45cdb42e5f255bb647544cebad5b2a7f0332a0376e5f7826cb20e64469a733f8a196e7b340ac29ba9aef92e0cc0634948d7946e5647b561e4b9799d8d3cc0033f04622b588b71ff590d4b6139fda38279ae41f53930cf710806e86eed854282bf243fe02ee157bbdcfe86fdc1e9be238f82c690fcecf9683c7074c57341d7e1ce8f21c6e6b09ae3cb654d000206d5b5b7b2519fc0b002658a2867ebd533e1ab139410e27f6e443af1df116b326f3d40c25eed5ef9313bdf18d04418dced1b48a2027c6a19640b6c764509725e3d9bcb5538540f511b5c88b4502037fea5a3cd5822a06e80e45ac5d3336f7539f0b8e03151d17b786d0c1bd0adafd41b0ca8877090725a79f02a66564620ddf8764dba32dacc7049bbcf2bf5902db85002402a8277692e6ffd32d6f6fdee1108cdcd336092ce1dd9daec5bf6b6170d8e5116dd37e9cbe52242af351247fc171aa8696a608f3b5730a5ae905fe00bc4f9e9c2f019be13e68dd27f695bbfb94e0e7f2fc459cb3f5e0303416d98c3349d91f720205e43ef412ddacd10b65097135420b63ad8054b48a2eb0b76dbb65d06814a271693355d2a06e55450928ac59fbb8b2855e125a64ad03101f28bdd2fb12e10ceda9feaeeaa52663e10d2e664bbb20aadd74a1d5e054162488dec6dc4373d9ac7ac3fd66443cd1cde2b805578fc287c7dfa83c67617b5609934bf2804ee3b8e1e4f56c048fc72c9e228ab687c4837e66080ec880e5dac3df55c2d8938b3367eb7f184c4346008a96e8c2a67e9460b3a1905c263aeb5b8db44bf2a082d771f4f0d320bbbf08226c496248ab834f4789b90d16d6d6f88bc3fdcda84ca23c7397a879c23b5b767b47e811304cd2df375094ca7fa61dfcc8947cbc22c973167e4cf6f5d6a853c59b769dbde3ff845b8c97fb38d6f15d69cc6edbb45540d04911aaf2b95df83491b03e61d6c5bad8fa2f4617924614944cd8d092d18d4039444b644834be9087719d7181080d59f1a54bb8e1f902d626ab6d648d8bcd22c273011156426972bd195847bbcfa9bb00124822325c18da5e352ad5a3d8db7fc0ebfd7f37138be2cc12b1ca15d2f075d975e9b26523876cdc0795480686cadd1ffee8c64496a8e02384f4a5bb012734ef37d4c59cc4772949876b093ff7dd6ed5d181858d238a79e8c19b5b44ff25d0c5c36e154885db0eecb7269ff25e89be5b50035662f1816a7b066b757be0ac3eb3b4d616ce11d6f2f0f8b010613c0392eb942051844275a024bf468ad26d096610eaa072ef64a44098891df0660c2ed1a608618710821b1575046ca29ac5c75705803ea8db3dd6495a5c2ad39222ae3a6dd6107cc9cf8a81d9019df40705227283a9df69a979b805a20986beff6723760d49f6539b73a515804ed49017c228a0dffa647f966b36b31a8e5a8ab5d640ac4cad1e6eb5776c36bd40443ed226afcc7c50ee23d86702538fee655c0bf69b48640fe555d854f244ff72bc56eb0ca24ccfd46813fe9e90f829fc170981875c3b7042217de239ac58ac57984f4b8828801bfdd35534f5edc1c562050454e33d6d29943cff7c9f2808056d646258187794afc2f11a7e701b4a5fc7f1270bfcf59344213cf17491756ad142b886720415e2268783e8ceb1e47edb8f6ae20319c9031119aa1c8cdaddc3573ee459bcea5c41088cb0203d7c60e54a36064ec6e757ec89b3917bf1883029ba067fb9d842c500d2bc2fb2ed4b64b7c5aa3176bceb00a9081bff10c2fefe6843becd609c321d0f8ef3c26f06ce32748cd7aa9227ac65a355ab9080e0d53f78d29fecffc5041fa64ecad54c06502eb8f0e7e1eed557ab3c9604535b62f6b0a683d9cbe2814fb6de2f12d531b52652764e0cc4a6811d6403eb43dc32306ae895170c494dee33b4be9b9ee7b29dad3431ad42db468958aef5f372bdac0f15d4cdddb14ba1fea9d7657fc344cd879afeb71844dba2ab9ff69abe55fc1f8a30ebaf3421e4eaad5389152578f90c193b1bb29876d948cf2092b5a8f0bbd4d0359e64be3b0d00b4a89c035ad2ce114beab01d0f573fdc254695c7d3fa5a8c835b10953216d820c7684ddc5258c85f5351e00f15650548c4cdf192100b769169421bd70cf918a20154a771bff5384daac43ad819f3da8ae27253fec9751764b77ec0e7a04d1b975132e4361deb18c06981ad6eb58a82eeab59e432ebe792ff56ed039f8914ba678eb30a8acde70627bbb36dd3891c4409f8fbb5359cdd974440fa6b15d3dfb72059e49e5a8619ade70c3046fb53f875aabcc7023795980ee078e7aa3299696ec51ae408e565da771c9eeaa8c53cffe07fd04cdc4f2e191bf8cea655267aef70aae172b86fa8eff2a9c4f5c9d9ca285a325010112b28e1eeda893a58a367920775d4abbbead18670387c05e97fd096e28c8f475087d78bd0493594dc5af131f26bc5042a1e2c219daf355ec0a38f17cd7cde9f80e242b9fd83dbba77deb0bab89e900b9be0a360b2cd4b8b121e452642682f186cf11b757c62373274dc4aa78d970b3a5bb1182098b80428fd614bbf3b1288c08041e74f9c1548b716ade180d3add50f193f6c013488f735956675802f30dbd302e627f91543d110bc2b5c7d5da94cfeb6d297a497995d0b5f3ee47e942b824d0a31d6371787f60c289487689788006cb6d027121199e0994bf8bdcdedb8d8e711b74b138846ce093018e490d71d02a7cdf8e187a740dc8fe465aff03a537564537e1428d6a58842d2ee17e295fa9caade6ba0717223475c665f0632d7d090ecb7e4f82a6db0db760dfaaccc84679b30fc32cc2505f0447b5179b32509c6c35823a1989d871122f2ffd12d0fcb6521dd57cf8d6faf88efad735a43ffadfc3faa18f5b5c3b57b2716adcdb24d9a69666866480beb1536e5e6c9b313e825e18209b62fb017ff3ea5be488b6eab114d12903d19046ad2a2830d4c5ca22d1d5b4472a70bc21f9ef898bd69bd5a75c1aca8c9ad52af1a710362a2833931c0138cc1385206b85d486e97463396e55e1776214746cdfc2c6b6a5a3390a016db903b772efc6ec9688e6d2d83387ecd30581eeba6f1cf52657cf9147a52c7750b3f4e86a72747c012e1d6acc9eb448b87f7a0d9706877f82bed0e76605a8bc64c141d8fe217c1969861616d10dac7f736513a6ecb7d2853fa7d206e507b4c34ab4ddcff8687c29a9a02229d37e09374b6ff89f294f3ede888d8e4e99cd16e602b26ff2575898ddd51a7ffe90d3bd60246d3dc25b9f0d28c72bfc53a5607dfe754ced1662b57b3201c433b264de94d9209a4c9d246323531f59299768206e757be6da55597ac7db29d9bc2cce21aa9d84a4aab53ebcb40ed8dbf6b46647c0e64db66f5301f4459631fbf2bef40c7b6b36cc56c8bcf079531c86de638e3ebaf906c73cb5d73b0d99f0e98d9c76fb871d0fd232cb8ed34f1d9c311857ff35d64b07c9640003594e499c76dd086ed6000cfc64cc158c195a18170c496592cd4718c4b3cf04e5b01fee8bf4d25ceb4c4041f560f0da14b99ed7c40c0c22722c0d5c0431a8dc17d5bfb23cf27645781ebd5d4cf64c2f800885144850e69f3bc40414cb1d404fd86231ce5995bdbd41696140ed1c46782a7893070fea4c66efc3201b97b95082e7fef5504a9ab34ad1b993a127d830d4c1f057550ee01b85e921fc15996fdff20f80690d4b1b97e1072a702ddaf0aa6aa27f584a8ca02c46b393b297db1e8a3f8ef53551310e2b7ac5092192866c598ac4fee8304000734cb048ba6b63b51ec017606705ad1c3789da191124aff0f5a6f3c22be9e1306b9462960f0271e12cb09bde69685793794f4a794a049ffa1c3ca50ba51cba14fa8a702889a2f5168a77b26e4ca84f82ca17da3bd00f75767ccf5b626d51fc70fa2c18531becbf2d2a8a11d106a921b58e3a9a23e20597a4e5cc1fd51b030a192fd4e1060330000000000000001bc465101206bff73890a12aa10f1b0fa36abd2a3aae6113a344a93abd55d2a9ff29a794f0692ae8e67b933321613735411b26ba81dbb7947dc319ed3d97093cc135fc8839998d85797a65a683a3812769df7a8ba069e39a20c261b9070c04c20df6ba04f2c6924c640003f4791b1367ef2e3d07c2e861093cb90dfedc4bbbd9d13207c6b2a22703563bff9e06b4a37faa0ec08ccad4d299cdbe0064eefdabce2878ed5e02e6d7bd23bc015206865065845d3ab1ef19c7f7c51916c254f7b6693395b27c3f7f708bd5a8bf7b9a45d48949bc78725f876361f3925b5a940e0a04fd487e65c92e0d7e17b8e0d3753a6b6878eeccd2f4e517983349613f44fe9e9d927a43799f713ec814a46e46cec2598eea6dbf5347c3af7a4520712bc93ca99ff14989237694bfd96493256fa378a10feabdd6037c89c9b50f64b145c66e479fac1aa9fc3dacb3f8709eb244fd3a3f66cff7a311ce99ef4b01f32d3a1f55840181ba870d21bbe6b7ba47123cd662c4a49a070c5890f9df3cab84c91a079638b6ce3c71804785a32b0f147cc75ee37efcf8971485c20f3d17a13fa14903d73783235714b445c44b28237f5375d111f6053322a52ce78a6f76e333874472a6d9fcc506ce10dd1c66b22aa4984a8ec6415617e5ccd6871e8c6bfe92e35d4396f94f1bdfe6dc989161bf4c5ae21493f820ff1cf0d6f44268fa66de3f666aa59ed1094f218ffc9b250586c0ec490479a169552d13f16220bc40b9aab6e692969cac82f113bfb8e968f2359c814f24066df9f85becd5f0a37efe01b31ea5e1996409d477b4e1905660e0c5e2024c50027e14d89bacdfcd6c350b7052f927e0909f967863070cc1ca3b2cc256488f2ed52a824efa9bf62e72c40caca46919486d2fbb74c92fb4039479085425af3c7100b0c5ad8da44ccebd0daa32abd29bd3e3f2bc82e0942e814bb8db78903fd73a4d9a4a842eda40280bb5e13b6334f971a1c5a2d043f3cabbcbc53c92e345f659bb6c09121e2c6e75295f5390540bef7b66e77e24f53588faa87a840bc7f6b44663262a1afbf766e80428817cef72a3edd76dfe32ca4048171fef1dda8d6013639cadd99f2f9c8f5da7a0c1a7adbe5558c5c19d2914a2613c0b18d5749898e15f4ac20e956d7a20573880fb53c392c1112c71fccbb93b8aba268ca3ddc056a65fbd21b76cc681fd417606a914a8056c9bc0f812a5e4ae8b8df856219cf9e116b30965807694d3ae8eca5fc66cf9fafe9fb2c701ca7b3456b5ccf4843411eb8f9e4ef6eef8c7953ef341e653e410f7885e94b2a0fb3ff08fd5078ccb726a153e6feda9890b3dc287f717d8a9d4f3251150ecd44bdd0bdcf744a86083c7ed27560130e5c714b01ea2e360abe43d65d16ee6e61af9955db68c047799c3642d8e70ce88995f818f5c27ef8cba8f62bf691d71299282053b113ee2ba993fd39d0592251ea85529bc3a3c7f51f5e6339101e1889a7d1b4c26b90c57926e01497ef1e58bfd5b358689eb65b2deda4dd290c014a284f0976f517e67d4f56d640744a3c5887bdbe2734b90374a089863280ed89d101843404bfa62ae6721c3985d31438ad812f9112f01f902078d126b995d96d31e889d9eb2beb6a67427cc1ad5ee113ea308359adc383708730de870bf54b4ffb891090a545ce5e90df29d90d6da5d102d27d746c07dd8ef252171665153f2d19bc25239a03c4809d569d2b7fdc3599473651a9430ffe35f9d0105a6cd85a6543c1ba5d6bb3f8a37b3e7fe8ab10906162952e280f4d288254adf239577d63edc1a4c2ab35ca37d31ec5f1a2671d9c3c8f306c67554e2b8ae51ce5d498b448eb13b572795e543972255813d8ea7f1b27f278abee9e480bf0171a58f9849c5dfdd708fcb75819ff604f37a2a5a2735dae1d619550553d4ce93900d15abd01e5410a3ddb02818ef3075332d4d8e42128d48b0079b9b6ade380b244506e1dca04c8d836082a7bf9f12c1220df4b3c33bb7182b7668a0837364c847477f0e24bed9402d5df53059f1f8307087ab9d943017cf996014ef0533b386fea55de964455721f1dc28c73172468a7c6642dc16c730db6137f94c8af637f45d6d83f61e12da78e1e577136a08acffab81ccf575c5ae14aac2485119987042cf7666857cdf6d90857b755dfceceff53ed85453e60427e9925e24fcca2c5c1dc8725fc2d4b9449a1bfec1cc7df92a322f164ad844b96417e74f6215a966800afd0a84f217e57f9fb930e536e7a4d9e3598c73c23f1d64f400354ea5e0db8b70a52a6187af137d2eb33b1a33b1464a675254e4aef3ee9add35734f1d9ea71fe983acac9765b1b8a57ef70ec591c02b5cfaddff2b7f2a22420a3c85024e72d651edc2b2a69c7d31dd20b4dfbe30425070b9f0a9a7bc2e6a4fd74fd4baf9772e54adb268780a7cb5b20ee8be5de24475f0e5f826d46ae24e3b213edb0da3d0027f46f2185ba7cf49e57d642ba5dd25edc0ec980d8014cafe52feaf6d88bf4428eca1ccdea28e31e04182f14ed2fc75923e91ce8fd5a7a4219e23303fc1f4ea98bd66c780e0152205e1780176793ef79c955b5005c40de8b4db30d3127a6769c13a09c3bb45f07c57f6f952de854d8feeba460bbc7f8119b8be9055a364e94a992763752da2e96f3eba7044e06eafda61b2699f14422970fb2d0ffdf9f7a80342da4f3387dbee3e8cf04ae9b707056efcae5bb74fd41fe954f133f4512dc967e4a413c02fd29d01714a18a1571c2c3943e77595057cd34f6cc44fae447ec961c8dc49eefcd0b0edd15ab9261dbb01e089c7ee347694614a166a97081757e941ac15cd1230717e926e51a2b6c25f8f83bbb3c6c9f7732f727846436cc4ea8c69a9527a26a8ba32047632836229be69c228b6155d63f362272e4fdf2cdd2d3c7f2f80350565aabc9e36a931e30216108588aeb901c61213e7906cc756cd8f43ed05211d136b1cad9e50897348caaf11da9bc7c3f4237f667c6e9082db00edc2771a056a215ee2f097a082a30f804f448123b6f90675e20137a914cb1b368579da1053766f3fda7997f5fd39ccaede40f2fd822f71131de065d72b5d838d1fa61f23143be8d5bd53f0d135535e28e753ea1c77708bef3241dc6560ac472c79bb1214cc8e95ac57820ff65d1fcfbfab5851fdcd9c5d67c0ce90b759f310f6bc1dec29b84dfba8e585e12497a3e547bec768878c320a7943f8f0248efc8147ac6634edc71a67421af209a00acd72b019bc338322a0da97d967d6b24f740c3ccda4aaab02f8b075dd97b06e4c4a3c494cf4e392932076c3ef09511a79b0d0e59776691e5d1b57a88c96da0471ff68ace378ce851f2c41d0176ba409e5eddd9c443148ab9736569c0e8aa18118c88efe3a49d0efa99e0a9d94c53402c8f10f6c56bc196b3849df4c2e65ab99aea84e066f552175d489edf0555f3fdb9cf046e92d421418d3cda02a00901fa59e973a2ea221741b3248e1f10b3085884221a2df712de5f2577f536d7a259ff381c654ed56263cf6ff5ed4a1ca15f97c3e30e872081c42eb8a79985567ea8f4f836df01e76a37acafa25cbfa2ce3d14284b65c1f51688be65084d663e3a24b8dd3a6c53515ba8b9f209642c803fda70baab6d7466371bf4586043f917452b886f81b369c9e31b152cf903f547259a20610983df2811317ad7dddf401ff028c3e98a9d618430411d22be8d95010eb5c012402e994aa72f5b4610ce18262345794c0fb44c03fdcd2ecc91a6e6cbfa6b2c4ab4d20390f651afc9b66471b383bb1b88af0dd93f7ed7f5eaf9dc996f01c2b26bbc0fea1012ee8a62eaa5d5576abce0a37826c78de8ac52d7be02031dc1ea5202900af551eabcc542285ea6c22682f29aa28f61f1362a225adde9a0437d5db3b5331333cf78c17601df31efe0f03a9cc1a4adab7cecbb422d9abc727940f1d5ab2a20839ad720e25bc5b2fc847588faf3ba2cea32b95e568cff1774742e2c18d45b9b6ac662c45345706253e58608dddaa815506b9e9a9c9469e29a3a0e398322819ecf74cc1f5db0a194063b1b224594698c0b38d4e8ed5c3bb8ed21649851bf0abb5a460168967976df003afb973cbb54ba2e000c418b78794ed88e0cb9783e746a9f3888fd567fd129aaf637166428c64022b1553328aaa3fd524449b5880da0fd94b4253e36b21e3270d5352e8fd3eeace5d526d5354368df424857c79d8cd39a9a85a86a99a7bebfcf272e5221a41396a460360db863fd6790a80d93af42ceb18d8cf4f33d0e6a8de08dedab8f07799ee6c9cd3985ef918cc7d6d8f0ce059e6ea6368994a22d678616ba123261bf62e71734fc6155556f7d12be94bc0c75163d5bab7505fa4b0a8b7102b0a9793025c63876b49a9872ddeef73c93b240cd8ee9bb6289f811e681149904de41129d2c7c923ffa427eb06e6a47e5cf622af755862b4ea1415193557f4a5b7c5ded51278a561bb45166bd1ea537ac618812b58ba1e68486b49ea7fc6d838c0551db27cf524d49bcac2b3cbd1f55f4cdccf1e7b0138edf0e77fca405f3ff2d1584ed9d6f4747e510e0b8194fc2f5e37688b90f87141bed3005f011494a5b866a17c5670f900723eefc4cdeada9f0690a07938e5111a213373ce5623d63a4c18fc2f0fc7d1ae618f4be90ea71bd227eb4fac6d05f9cad4bd92990d15a594cd16ea1668d15c5896feb2a77335ed6eceb3b69624b84a83a613e384cefcae32cb8d8797a688a2216b30efd62c2534116d9c18dbb19adc03f4df77fbe6f23c8d0aa71afe2b21a4e17f6cca97d2874cdc8f57e8a024096091fdcc11f6c573c81f32cfa0838f4267b534501136f8e9603b504bbf1637fa81cb34f0aeaa1013c579558ee2308898eb64c13d7d9844306da84a0d1f43ec3d1d158273d3075f1da3aa2b8f5db1749db75408150296e6f63b3503e21b0420a81f8092d4e7058e6025a8a5b8cce3e131b97dded447cb5eb87cf4a4ef6cdc10577d162d58a442831b07aed80d32eace2c8a85eff1afe1a05c18424562d069b0c57b97402e015d6b8e5598906292c09942f267b6f511d808f99d18fcc2ac83f9a0c0c5e24e2cb2453244fef227fb11093bfd68b1dc4ac1675fe45ca1363ecfed65d6bc94b5bf7f22eca626bcb75a2390023c6c0e2840aa572d85b2337b8a7ca4c58216082a4cc32e68cc129f0fb5def3d3d0a438a6a4bf81bcb6aa8e7c5c3ff866bb68c2b86400682248411978f9f247a3433cca781d0c6bf8da4c70ff564003e454409333ef1bb61d391d0e45cccdb41a6f3afab7fe99483fdf2598b6c2d9749ce7666207bfee75d51737f824e141d7aad8d31d10f368d0850924c753793f0ba02a24f6c084a4c73d6d28250d5332e4d2bb27ccdb95c8844c05948686a73b80be8d8d59a3e094b2076b4b2deedd00cd23a064f335409a89181ea5f9cd0302fb13f88dfa726d5c7039ff9bfed447cefdf283e943925d5a4ba9a7ee65a9e973b4e3ee56ad9740cf9ebe2be0536388ef3a84e1e17ed19d36591d2311120e7c59da1016d9ceec87d05bb73b04f87ff0b9ec6354a731c265d4d3bf5181bed5e3b9dee218a4840c56c60cd5382b12d35d22c62aaae90af4ab149f244cb0e21dfeae0bc21c2675b48249d340e6cf9b5ab7f80b2d5dfe69ef7acffe115ca0dc71a074e30531d4c39bfb313962375ac09f9deafe95d0251e6547c2f5fb831081f365e49711ff1da308f207bc888b2e14edb99fc06d567fa35525dd4cbc9105f565f9d7cc6baf9146ab5da76af8c77a5a08f318360616009cc907193e83dbc308a6dcb012a09173b8c038c5969ebd9f8ec9cb22c512de6fae2c22528b37dee61077c600e7e5859e2a59bc56cb76990981e91b112677eebc7233bcdc987e61b00008304000b8f969850764ddde29e5dc2d3bc64f3a3922eef846b8f41ee172ac5eb375658be34d651310ed0ae5baf4dd2e08d4f0d720bb7142c5ebc5e31cba7a10c64dd661e7ab5c592bd7b0cad789e49c274f2a5e8c7b30d8350bb43072ed09cd4afb66f8275cd5607a55d061f4fcbd18c70f3d1cf6c4cfa38bfdf50bf07c3b92f8239279cfd4e106033000000000000000117b96b009063e2a5083ea37b42389829404aac49bf57a9747405f0cdba1e98f0834d04ef48edfc8b3f763dbd15e1925bcd2d60cf1a9ae9aa90c059518e13877adce18833be3008d36f9d66824d22ba3b6cbe88790ee5440503b5cd8eb5c352966d36c3ebd88d824fc5b7bf62fcf599ac28e76e360c5bab6eabafa1911a048bb1410e1a8b76bfa0dd11276eaa109d447a7ed85c66412ae17804797970732187d63a67edc48845019cffb5635e9058e3b7dc36520b1b4ee35e66732c141703bb66ba12540d8b0a8356af623e8f97578f4e36d9cb3e1e40075b31a92fc6d71906aaef00b3f06cdf6c09ec40cc21c075766518b00938d3dd90b48115bc7c297ecd915f314c4f3dd84addf321d157690f7a559d1d24cf06c47c11d962526399e87c8d3443581b2071da5fe1f210d84c62ec8d9006e0600bcbce85bed8aaa1418c79dab3c4d28eebb74ed30fb6cbe6abe7629411d814fcaf11ac2ec84cdced52528da1093ebdb4350cb24adfb3b7bca2267418736d22cb1ae92fe064825ad749b13d559a4a82f3cba4a1ce56249554344cc13e076fa71cf1b6de2cc061d40ed56c41ece3755b3cf1354b67e065f49bd8bc76e074c5ad8f0d9858e92f70094eefdf83fa0f1232b8878707c8d17ac0ed347d66ee71fa7cba67079ee0b6d78e411bcc2909d90dfe7a2d8a0f5c4752a9fe9d66cff970730f6bf2cecc8e783d24bad48245cd1e28551eb5487066f80388571b5bc51b1a43d5c0ebdd4197c1cd1f07e0a711ce743ddc14840966f1e1c1207d7a6b659e8da9840a6c65696fcd38929b34844d36e69676ea79116748c23c8b355a079e0aad102dd09499fa7e208ef13f6264d6091f2df352b17bdbd182683239d0e300a91c1bbbf4cf9998fbab7c627804aa29ee9fc58affd736310beeb5cbd9ae29b327eac256f12818b948e45992cf89186baf3fd992717233d844fa7373bfcf8d0742a8a38fcd6b7258b47a2ab23281ff03c69ab68f336efa5e6a6ce7d9ca9a689333bb45662923b171777d7810c5d17fe8cb4f2cfd8ea0fde93e280dc17959e54a2580f88049c336959a3ee3d6fdd33283e906c3676ea1fc8c2645440f3ec6d753980d006f0481a3be84dbcb2de646024a2b9da93873957b486917bb07168da3b3d839ed11f0050a61ac3cff125382a439bb60ba5288babeb4a71aa957e2bbb3273c5e82a643f791e7ba2a8a93ed2736baee2e199cb5c8ab6e1053d730849809a412bc5dc1ded7e9d18b1ec2a33cdfed8c4b6c28a183155df8ff0ab0f1da0bbfce767f55e2525f731fdf05e88fbbc045c3ecfc23e3f6e1e7d57d619c88db95ac35652291d3b78fdc61e45f62ad226306f39a031c41d1ee3ed630f2cc52deada2b0d8dc5dc268f5dd0de062615ad28c879cbd1c94092c77d5cf92bc774a44901564433a1a6645ab31deb3902c8d459aaa18d4b6eba4e5c63a46751981bb8d3b51aff39e064c798cf4ebecb16dcfce8a5f3ceeaf91d7f62807417287c7de009eff2a85ba4a70972f40540e0739a443cd1552c47d2b780e3320d3c514321918dc33e4ecf596f7a344ae2241e044ff70d06e134e68219fd5ffcb7a12aef1f1f31766c301935ed667ee57376fa856b8fe3a499cdc7d33e6680e12ae8e6285bfc63a0325da883d30ffa0498e4fe2154ed843e1f180f2a058e6dcd0a1cdbd138c4eaf389636954454ffbe928805d0ae7a322c51a105641b3bda84d96cb3706f60ced4a2ef3a7cd63cc17c053d2ec9702bc7542d1e4db98db703604603f1dfe777b63454f4f239b15ec9458209c77b7e60c735f919ad9070fdf85891dd3296adb745305d3d215ea76e644a1dca72d3e1cbe199b0c11b18928beeaed410766c8f98e50bb44fc3b19b8d502c8ad61930b16004433cf0c322e9ab6c4faceb06e3ca25826883a67486ee1df89d0b8b2929ee351916b4aead312047d4320646a3ba368a3e886e1c6e7eada9087ef5a84e79b0ab0a3796f5ab0cf1217aa07d1ae1387c2dc6092cd02b6ab6b3c65ab761a8976e74b251128bff432d7ce6de00ccd711c30838978b0c4dc328502b5b42906d401f5b66fd175285ca7d59310084357a5915c43ba89c77971d6cb0db6354b2ecf14d03dd624073ef754149cdab8af01fb069394446b408b48b6a0bd2ec14562c73b4ee44fecec39b7ae26a8f8ab706706f030e2edf4a2235d11b798896b738e2441a6693d9f1dd8af39d9f95731fbc7aecfd056129a9bcfdeecb46581fac573c844e98e4f8ce74fe60da2cd8f19c48efb6da2521972a840bf38bd9ad57be2e68cb60adc0e859ae5505e230c82e51eecdf38e80ed5e73d1d9f7838aa14355f22bab25a91a3c60b3391b71d8995e3a082a37bdc5eca47790828bd269135715794bf34d4c05b686cc0c52d6e62fb274f564c69b0801906e07f7499a0865fd27db999f574292b6edffbf1abf678ef0ff2ca869b5c4f05c0d5a832362e9c7af91d5f4d81923c7232d1c2e4693433dac36b4ceb8d300ddf5493867965ca4e8feb8a5961952a76dc750d9ce733d318f43ffe02431493fe7e86a22a3d1a71cd86e8afc6f1e64be83ed0759249caf8cc3e05adb513760a1427abc90043b9662030530822662baca4febbbf034564168dba584f299acf7537ee4d8d6964ce5d96e858750cfb0c4eee87d483eb79237a8bab53a1081911cdd82d14979f26d33bfdcf5e19ef216dea8503c89f07dc579b572ec3a444017a787996325392f876417e83b2eebc525eca41277f2baf98255d1b70e75e3107057cfc66215e152889fc50aa31bf133d1fec7d24f215624e6357cf0ec0c9816393181693a14f9cca48504946f68277066685073cb9af8fea22fbee2a5570708ce2e6a44fcd68ad2222a8e03af33eb70a0f6fe871af8c5b688eecf290f757560abb6338bbb0f849ab39d0f26258ea17385d7ae59bafea0fc799d36197ac5aaed9b485e10c8bdf6f931ff7814b049731c24c16d508442d1c4fcc3d01d8dfb557e9c0e2afea87315969fb5ea07c4697d7368db25b2b2192461109a5b2fca89b7b63709fbb3327d2b00fc6d6f9e16c83b202dc8bd26c5bd1ca1693cb1256950ca7beacd2c61382e103d9510d1a5cddc7b285603920ab9fa6bcd77cab566b30d7454fe50aead926c9e5edb22bd9ae79f0bcef80db0b6fe1e43a00be0ca23b89d5cffa113200b4b4f3041cae7d9623f3b1e5a46f04fc95d33d6e931219dda120d72456ac753b0c02fc509ebb4f020363fe7901b82a01a14c9ee2c09f1342c031f0e74a7a939715bc725fc5896c5754e0a618bd50cdef2ffc2e65ce3f78da4fb6a7e3d07166d8bd14b42cd44136826b87732e837bb4ac5af23988be02961d78361fd07ffee65d19157cf9cfa659286d6415db5c05f0d8065f8e501fda8cb3a6a596cd36086d30fb6f7d6df8efd6e3160549b40194bea8a631d2906e713d9ee5798eac674887466b2b1fb63b8097d672ce62478b0e4c7f5a8ba85c0227b3d51ea0763116cc46e47aba225bc6d3e0ed7a66b6a98284c6fc24176998d467c3e44b2cc23984abd21aebf5520e4f7807ed03969b8827e39974da72c3993b09284102170836250efaea4b465c45ad3cfdf6c823cecbabe66697d0b8dd8f47863d6d9c9d64dc8d6495975479f330dd31ebc9bf1e9e05205e553287c6b378b8424caf9e4caad026f09556b1a9fa91d5740daae8a45de26a0ae836cfa6c05da141981e7ff35c1448bd0799381c88a3e8d6148c9bfb4d26aee441cd330800655ab078177389a40b7ee801848b463724094d09642332d5aaa234029155f5958284cbd3dd4a3cf8da286e49c896df6d8728e6e9ad6180051e75907c3450ec373021c4d784f3f62b49cfb1e47624ec69367260d97e7eea9e104ef76ccd12ccac80495c0af72b43789f4b814aad8b762460ccbfe0aa84591624dd9dbdce72c6e5d72f943305759c0baabc294f3c062a86d348bdb33bf5d6c40616ffa85cbf59930d505c6a0cb36b8af2b151dc8839d1957cb8de88de20ea6c3e78d12b88867efada2fb6f12df80638bff1e1594722fb0d667b58f4c6c17b7aafad4b59b625bbeeceaf29935d96126a8427642677dd5d0f6cec3c3de7b2d41f6425ed71d7d66f61c4b4ef4ab1c5c5f5695e0abad6f65266bb3a705e7b859d0d0ab6ae20131fdde6997e34f5a7b506b4bdbad724373faa4bbaab3a0e7ef51f62107cdb3b78f60693d0cd6554d8b45a059050d70875e6553cf6723e9a00506d26c66d5ff12cbd76fdf7290f28517f57dd3b18b1986287f035ef2847df56a2a31af96dbd3d97721e4a167cebbb665ae998fcc27da46f8deb5454158747e6fcd9a6defd894a4c1b7053258cc88c58b17a8d8091c07f8fd0cd9a90cc0a71b3ea4cfb75ccaeecb9761dfbccd58326af050b40b0af57d2f7f47dc84dcb41a9447c1a04cd887acd214397a80f15a9ebbb81cdf59bf06d90f4b2d60dfc7c76b63b140d5fc60b5a5d9bedea3f817a087c354db619c1e333347b7929a9ff95dfd1b891991878cb86f6fdf78781c697ea572bff23572f3fd22014955895cb52089215e79cee7df038a170e4bccd4027b049a9220b24da95cc31db9d59ea82ee0152998214de40b3143aab42519226ef1ea02536bbdbac8beccc7d7090ee5f62875925740ab4af5f5ae3da9e30ac90fc429a161b44cb316a6f12004b051fe7d308b5abb3eede0409054e641f468b40a93fff94c0e3d704f7d9666c337e7d61ae6255441b15be8c3fd68e461b0d15a72ad231aad3d65b7728f85815bf3f29fe1f382a38c675c4356cb4c848b6121d3c8c7a15747df094ae9e4a7396c5fa85926c6285258a277e3eccaf98aafb9e0c2b8940f1b49081353fafc155a888e4feb2e30d0939a50bb80d1188dd262d2c191175b7135cc13bffcca1d1253218156c5deaf31842e6a34f6b2736707a2ccfc181f31b19533b5f21c4987912ae7b8f76f253bef706a4c0d537f890cfb7578a24fac431853d5f6f046a3924c45866edfa5a4f33802ec1c57213abad755afc7ceeb69347d9381ed05641bec9eb7527774fd2053dffcef58f7e654da291ee2ff745d43fe096dd1ece2f07468e64e1fc188ae1ed046457e14dad92feafd1bad54e0f87bd59bcb6cd6160431067b9cde6d4f132a41e862fa925dd734f7241280e0efa59a6317df389b2ba770233bc2e506f6c5512a944ccca53a58985f3c4744f4bf8a3c52f7d7f4a5ebc077a0b0d48317f2c2c001c2dd3b206d261e3a1118a6d44945e34284a5e868bd7e4a1292c84b95dc91568fe96d3e09d155f81dbbd82e6a0eab6578c2068a30b048a945f6ae00a297d88e3b3af4ce60c133e101384b806d0b6b707c00d1284e9bd6ecabb10729a04adeacd145eb9a5b0431abb3594d1cb07edb8b7614b2a2e36361325f99df79375159c787f61a44fdbead5d48cc200b96ef0e8af4da218479885504ec9420f232747b9dde8f593c9096f3a407b22e22c9168294c2e0322519340084f51ab7aea1dd5027e3cb7cab7061b3fd573c61edccbd23775525cb17da9fe6c4de4665a62d83fa843eb567599210bc9e98d607572008de038770b3dab2533610a74a0358821ed0d0b6a05f6a2bcbe6c7fa07237bbf64ae66af64f78d44ee0743fe7a0b14b89ce1a9e5570d8c3b1ded22bdcd543b3a96b0e13ecd3e0663fbc7defeabf10bb224632cd219b963b7ce3ea42ae422d2318bfb4c4fb86bb640fc8c1f6ec2362560e20cb3ddbad2690596ab889ceec5c1609899fe6bcf7f83b3894674e52250bfd87bcf45c4c96080594b595881a1021bddfdddb1d04619a283bc95f5c5d476fcc5beafe2b78acb6713a0cb03fd2e12521e6c2d4f8d5d748feecfcf038bebb9aff49f753fa9db8c61cb52d25626f3864accf53be13e274af8';\nconst walletUtxoList = [\n  {\n    bip32Path: \"44'/0'/0'/0/0\",\n    txid: 'b65b249e3ff74cc5e97675c59f2b6d74525642652c9228716efa9689e95bcc54',\n    vout: 0,\n    amount: 5000000,\n    valueCommitment: '0982fa3e72e46a902e7f022ff3c63339559b15bced82470660265f8998e614dedf',\n    redeemScript: '',\n    pubkey: '021a8cffee67e4a5d8e9cfe0e6dbcc86484b425e93508522224c32bbba96fb6d82'\n  },\n  {\n    bip32Path: \"44'/0'/0'/0/1\",\n    txid: 'b65b249e3ff74cc5e97675c59f2b6d74525642652c9228716efa9689e95bcc54',\n    vout: 1,\n    amount: 5000000,\n    valueCommitment: '092de99d82734c97e8b87918b884e521f7ecc53a296d78c5f327e9ca3b4e105a82',\n    redeemScript: '',\n    pubkey: '0284077c532859caecd38c639369cabfe880dbfe3ec01b68a6e94242d4f580ba50'\n  },\n  {\n    bip32Path: \"44'/0'/0'/0/4\",\n    txid: 'b65b249e3ff74cc5e97675c59f2b6d74525642652c9228716efa9689e95bcc54',\n    vout: 4,\n    amount: 5000000,\n    valueCommitment: '08e028ce0bb37cd23d8c4a7f2348db64f5042a9d3f8f030d881cb623b5861edf22',\n    redeemScript: '',\n    pubkey: '02bf9096fad22bf6aa4d55c18447f25e6bf0c79ca5bf7d3e7e191db3eb737b600c'\n  }\n];\nconst authorizationSignature = '30430220307607146431862975de982412170cc9b45f3cfa2abbd351c634840b785f2785021f3c478b9de2cb55801fb924c5c219ebe71d58f8d09f6df32d8e17c105ded6a3';\n\ndocument.body.addEventListener(\"dblclick\", async () => {\n  $main.innerHTML = initial;\n  try {\n    // const transport = await TransportWebUSB.create();\n    // transport.setDebugMode(true);\n    //const appBtc = new AppBtc(transport);\n    const h21 = document.createElement(\"h2\");\n    const h22 = document.createElement(\"h2\");\n    const h23 = document.createElement(\"h2\");\n    const h24 = document.createElement(\"h2\");\n\n    const networkType = 'liquidv1';\n    const liquidLib = new ledger_liquid_lib_web__WEBPACK_IMPORTED_MODULE_0__.LedgerLiquidWrapper(networkType);\n    const connRet = await liquidLib.connect(0);\n    if (!connRet.success) {\n      throw Error(connRet.errorMessage);\n    }\n\n    const lastConnInfo = liquidLib.getLastConnectionInfo();\n    console.log(lastConnInfo);\n\n    const { version, name } = await liquidLib.getApplicationInfo();\n    $main.innerHTML = `<h1>${name}: v${version.major}.${version.minor}.${version.patch}</h1>`;\n\n    const { publicKey } = await liquidLib.getWalletPublicKey(\"44'/0'/0'\");\n    h21.textContent = 'pubkey: ' + publicKey;\n    $main.appendChild(h21);\n\n\n    h24.textContent = '';\n    isDumpSignature = true;\n    setTimeout(async () => {\n      await dumpSignatureProgress(liquidLib, h24);\n    }, 500);\n\n    const { xpubKey } = await liquidLib.getXpubKey(\"44'/0'/0'\");\n    h22.textContent = 'xpub: ' + xpubKey;\n    $main.appendChild(h22);\n\n    const calcInfo = liquidLib.calcSignatureProgress(\n        proposalTx, walletUtxoList);\n    if (calcInfo.success) {\n      console.log(`sign utxo count = ${calcInfo.analyzeUtxo.total}`);\n      console.log(`tx in/out/issuance count = ${calcInfo.inputTx.total}`);\n    } else {\n      console.log('calcSignatureProgress:', calcInfo);\n    }\n\n    h23.textContent = 'getSignature requested.';\n    $main.appendChild(h23);\n    $main.appendChild(h24);\n    const signatureResult = await liquidLib.getSignature(proposalTx,\n        walletUtxoList, authorizationSignature);\n    if (signatureResult.success) {\n      h23.textContent = 'getSignature success.';\n    } else {\n      h23.textContent = 'getSignature fail.';\n    }\n    h24.textContent = '';\n\n    console.log('signatureResult:', JSON.stringify(signatureResult, (key, value) =>\n            typeof value === 'bigint' ? value.toString() : value, '  '));\n    isDumpSignature = false;\n    // await appBtc.getWalletPublicKey(\"44'/0'/0'/0/0\", true);\n    return false;\n  } catch (e) {\n    isDumpSignature = false;\n    const $err = document.createElement(\"code\");\n    $err.style.color = \"#f66\";\n    $err.textContent = String(e.message || e);\n    $main.appendChild($err);\n    console.log(e);\n  }\n});\n\n\n//# sourceURL=webpack://ledger-webusb-sample/./src/index.js?");

/***/ }),

/***/ "?ed1b":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ledger-webusb-sample/util_(ignored)?");

/***/ }),

/***/ "?d17e":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ledger-webusb-sample/util_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;